<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>ScriptableObjects&middot; Antonio Moon´s</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Moon Antonio">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Antonio,Dev,Game">
	<meta name="generator" content="Hugo 0.50" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://moonantonio.github.io/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://moonantonio.github.io/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="site-header">
	<div class="branding">
		<a href="https://moonantonio.github.io/">
		<img class="avatar" src="https://moonantonio.github.io/img/avatar.png" alt="avatar"/>
		</a>
		<h1 class="site-title">
			<i class="fa fa-angle-right"></i>
			<a href="https://moonantonio.github.io/">Antonio Moon´s</a>
			<span class="logo-cursor "></span>
		</h1>
	</div>
	<nav class="site-nav">

		<ul>
			<li><a href="/about/">  </a></li>

			<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/devblog/" title="devBlog">
  		</i>&nbsp; devBlog</a> <i class="fa fa-gamepad" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/backdoor" title="BackDoor">
  		</i>&nbsp; BackDoor</a> <i class="fa fa-black-tie" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://github.com/MoonAntonio/rec.repos" title="Public">
  		</i>&nbsp; Publico</a> <i class="fa fa-code" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/portfolio/" title="About">
  		</i>&nbsp; About</a> <i class="fa fa-terminal" aria-hidden="true"></i>
  </a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="&#43;">
		</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
	</a>
</li>

<li>
	<a href="https://moonantonio.github.io/" title="">
		<i class="fa fa-fw fa-home"></i>
	</a>
</li>

<li>
	<a href="https://moonantonio.github.io/index.xml" title="Subcribe">
		<i class="fa fa-fw fa-rss"></i>
	</a>
</li>

<li>
	<a href="mailto:antoniomt.moon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>



<li>
	<a href="https://bitbucket.org/MoonAntonio" title="Bitbucket">
		<i class="fa fa-fw fa-bitbucket"></i>
	</a>
</li>







<li>
	<a href="https://github.com/MoonAntonio" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























<li>
	<a href="https://trello.com/antoniomoon" title="Trello">
		<i class="fa fa-fw fa-trello"></i>
	</a>
</li>

<li>
	<a href="https://gitlab.com/MoonAntonio" title="Gitlab">
		<i class="fa fa-fw fa-gitlab"></i>
	</a>
</li>

		</ul>
	</nav>
</header>

    <div class="content">
    <article class="feature-image">
		<header style="background-image: url('https://moonantonio.github.io/img/bg.png')">
			<h1 class="title">ScriptableObjects</h1>
		</header>

	<section class="post-content">
		

<p>Los Objetos Scriptables son un tipo especial de objeto de datos en Unity. Tienen varios beneficios importantes, pero es posible que no funcionen de manera ideal para cada situación.</p>

<h2 id="introducción-a-los-objetos-scriptables">Introducción a los Objetos Scriptables</h2>

<p>Puede pensar en un objeto programable como un objeto destinado solo a contener datos. Si ha estado utilizando clases o estructuras tradicionales de C# para objetos simples solo de datos, podría utilizarlas en su lugar. Por supuesto, usted se estará preguntando &ldquo;por qué&rdquo; le gustaría usar un Objeto Scriptable. Aquí hay algunos pros y contras:</p>

<h3 id="pros">Pros</h3>

<ol>
<li>Pueden sobrevivir a una carga (como cuando construyes tus scripts o cuando ingresas y sales del modo de reproducción).</li>
<li>Se guardan por referencia, mientras que las clases y estructuras normales se serializan como copias completas. Esto puede ayudarlo a evitar la duplicación de datos.</li>
<li>Pueden manejar el polimorfismo, mientras que las clases normales terminan siendo tratadas como la clase base.</li>
<li>Se pueden guardar como un activo del proyecto.</li>
<li>No necesitan estar adjuntos a GameObjects.</li>
</ol>

<h3 id="contras">Contras</h3>

<ol>
<li>Debe heredar de ScriptableObject, lo que puede romper muchas de sus opciones arquitectónicas o de diseño.</li>
<li>No puede crearlos usando constructores normales, sino que debe usar &ldquo;CreateInstance&rdquo; en su lugar.</li>
<li>Los beneficios de serialización no son igualmente aplicables al tiempo de ejecución.</li>
</ol>

<p>He creado varias mini demos para aclarar estos puntos. Las dos primeras demostraciones muestran cómo podría encontrarse con problemas si no estuviera usando ScriptableObjects. Las dos demos siguientes muestran cómo ScriptableObjects supera esos mismos problemas.</p>

<hr />

<h2 id="demo-1">Demo 1</h2>

<p><strong>Pérdida de referencias de objeto en la serialización</strong></p>

<p>Comencemos con algunos ejemplos de serialización. Comience por crear un nuevo script llamado &ldquo;Demo1&rdquo; y otro llamado &ldquo;Demo1Data&rdquo;, también agregue un script de editor llamado &ldquo;Demo1Inspector&rdquo;:</p>

<hr />

<pre><code class="language-C#">using UnityEngine;
public class Demo1 : MonoBehaviour 
{
  public Demo1Data dataA;
  public Demo1Data dataB;
}
</code></pre>

<hr />

<p>Este script tendrá dos copias de la misma instancia de &ldquo;Demo1Data&rdquo;. Usaremos un script editor para crear y asignar sus valores.</p>

<hr />

<pre><code class="language-C#">using UnityEngine;
[System.Serializable]
public class Demo1Data 
{
  public int value;
}
</code></pre>

<hr />

<p>Este script muestra una clase C# estándar muy simple. Se puede serializar, gracias a la etiqueta &ldquo;[System.Serializable]&ldquo;, pero Unity no lo manejará perfectamente, lo que se demostrará pronto.</p>

<hr />

<pre><code class="language-C#">using UnityEngine;
using UnityEditor;
[CustomEditor(typeof(Demo1))]
public class Demo1Inspector : Editor 
{
  public override void OnInspectorGUI()
  {
    DrawDefaultInspector ();
    Demo1 myTarget = (Demo1)target;
    if (GUILayout.Button (&quot;Create Shared Data&quot;)) 
    {
      myTarget.dataA = new Demo1Data ();
      myTarget.dataB = myTarget.dataA;
    }
  }
}
</code></pre>

<hr />

<p>Este script proporcionará un botón en el inspector de nuestro componente que creará una nueva instancia de &ldquo;Demo1Data&rdquo; y la asignará a ambos campos en el script &ldquo;Demo1&rdquo;. IMPORTANTE : el script del editor debe agregarse a una carpeta &ldquo;Editor&rdquo; o no funcionará correctamente.</p>

<p>Crea una nueva escena. Agregue &ldquo;Demo1&rdquo; como componente a cualquier objeto de juego, como crear un nuevo objeto de juego vacío o incluso adjuntarlo a la cámara. Luego mira en el inspector. Unity creará automáticamente nuevas instancias de &ldquo;Demo1Data&rdquo; para ambos campos simplemente mirando el objeto en el inspector. Puede asignar cualquier valor que desee a cada uno de los campos &ldquo;Value&rdquo;. Si ingresa y sale del modo de reproducción, los valores incluso persistirán, hasta ahora todo bien.</p>

<p>Salga del modo de reproducción (si aún no lo hizo), luego use el botón &ldquo;Crear Data&rdquo; en el inspector. El valor para ambos campos debería volver a &lsquo;0&rsquo; porque ambos campos ahora se refieren a la misma instancia nueva. Si modifica el campo de valor de &ldquo;dataB&rdquo;, debería ver el campo de valor de la actualización &ldquo;dataA&rdquo;. Sigue luciendo bien &hellip; al menos hasta que ingrese y salga del modo de reproducción. Pruébalo, luego modifica el valor de &ldquo;dataB&rdquo; una vez más. Uh oh, ¡los dos ya no están haciendo referencia al mismo objeto! Unity ha creado una copia completa del objeto original para ambos campos.</p>

<h2 id="demo-2">Demo 2</h2>

<p><strong>Pérdida de tipo de objeto en la serialización</strong></p>

<p>Esta demostración mostrará cómo Unity no puede serializar correctamente el tipo de un objeto. Puede encontrar este problema con una lista polimórfica de objetos. Crea lo siguiente:</p>

<hr />

<pre><code class="language-C#">using UnityEngine;
public class Demo2 : MonoBehaviour 
{
  public Demo2Data[] dataArray;
}
</code></pre>

<hr />

<p>Este script tendrá una matriz de objetos. Cada objeto compartirá una clase base - &ldquo;Demo2Data&rdquo;, pero en realidad se instanciará como una subclase.</p>

<hr />

<pre><code class="language-C#">using UnityEngine;
[System.Serializable]
public class Demo2Data 
{
  public string name;
  public override string ToString ()
  {
    return string.Format (&quot;[{0}]&quot;, name);
  }
}
[System.Serializable]
public class Demo2NumberData : Demo2Data
{
  public int number;
  public override string ToString ()
  {
    return string.Format (&quot;[{0}, {1}]&quot;, name, number);
  }
}
[System.Serializable]
public class Demo2BoolData : Demo2Data
{
  public bool toggle;
  public override string ToString ()
  {
    return string.Format (&quot;[{0}, {1}]&quot;, name, toggle);
  }
}
</code></pre>

<hr />

<p>Aquí hay tres clases, una clase base llamada &ldquo;Demo2Data&rdquo; y dos subclases de la misma. Tenga en cuenta que nunca instanciaremos una copia de la clase base directamente.</p>

<hr />

<pre><code class="language-C#">using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(Demo2))]
public class Demo2Inspector : Editor 
{
  public override void OnInspectorGUI()
  {
    DrawDefaultInspector ();
    Demo2 myTarget = (Demo2)target;
    if (GUILayout.Button (&quot;Crear Datos&quot;)) 
    {
      var dataA = new Demo2NumberData ();
      dataA.name = &quot;Demo2NumberData&quot;;
      dataA.number = UnityEngine.Random.Range (1, 100);
      var dataB = new Demo2BoolData ();
      dataB.name = &quot;Demo2BoolData&quot;;
      dataB.toggle = UnityEngine.Random.value &gt; 0.5;
      myTarget.dataArray = new Demo2Data[] { dataA, dataB };
    }
    if (GUILayout.Button (&quot;Imprimir Valores&quot;))
    {
      foreach (var data in myTarget.dataArray) 
      {
        Debug.Log (data.ToString());
      }
    }
  }
}
</code></pre>

<hr />

<p>Este script proporcionará algunos botones en el inspector de nuestro componente. El primero está etiquetado como &ldquo;Crear Datos&rdquo; e instanciará cada una de nuestras subclases de datos y las asignará a la matriz de datos de nuestro script. El segundo botón está etiquetado como &ldquo;Imprimir Valores&rdquo; y hará que cada objeto en la matriz imprima sus valores en la consola. IMPORTANTE : el script del editor debe agregarse a una carpeta &ldquo;Editor&rdquo; o no funcionará correctamente.</p>

<p>Crea una nueva escena. Agregue la &ldquo;Demo2&rdquo; como un componente a cualquier objeto del juego, como crear un nuevo objeto de juego vacío o incluso adjuntarlo a la cámara. Luego mira en el inspector. Unity creará automáticamente una matriz vacía de datos simplemente mirando el objeto en el inspector. Llenemos nuestro objeto con datos haciendo clic en el botón &ldquo;Crear Datos&rdquo;. Debería ver que la matriz contiene ahora dos objetos.</p>

<p>Aunque la clase de datos base y sus subclases tienen la etiqueta &ldquo;[System.Serializable]&ldquo;, no verá los campos agregados para los campos &ldquo;número&rdquo; o &ldquo;alternar&rdquo; de las instancias reales. Esto se debe a que Unity los trata como a la clase base, que solo conoce el &ldquo;nombre&rdquo; del objeto. Sin embargo, los datos todavía están allí (al menos por el momento). Haga clic en el botón &ldquo;Imprimir Valores&rdquo; y debería ver la descripción completa. En una de mis propias ejecuciones vi salidas como las siguientes:</p>

<blockquote>
<p>[Demo2NumberData, 84]</p>

<p>[Demo2BoolData, False]</p>
</blockquote>

<p>Se ve bien hasta ahora, ¿verdad? Bueno, veamos si puede sobrevivir a una carga. Adelante, ingrese y salga del modo de reproducción. Ahora presione el botón &ldquo;Imprimir Valores&rdquo; una vez más. Debería ver un resultado como este:</p>

<blockquote>
<p>[Demo2NumberData]</p>

<p>[Demo2BoolData]</p>
</blockquote>

<p>Al igual que Unity no sabía cómo mostrar los objetos correctamente, ¡tampoco sabía cómo serializarlos correctamente! ¡Ambos objetos ahora son instancias de la clase base y se pierden sus datos de subclase!</p>

<h2 id="demo-3">Demo 3</h2>

<p><strong>Las referencias a objetos Scriptable sobreviven a la serialización</strong></p>

<p>Esta vez recrearemos la Demo 1, excepto que usaremos un Objeto Scriptable para nuestros datos serializados en lugar de una clase C# estándar. Crea lo siguiente:</p>

<hr />

<pre><code class="language-C#">using UnityEngine;
public class Demo3 : MonoBehaviour 
{
  public Demo3Data dataA;
  public Demo3Data dataB;
}
</code></pre>

<hr />

<pre><code class="language-C#">using UnityEngine;
[System.Serializable]
public class Demo3Data : ScriptableObject 
{
  public int value;
}
</code></pre>

<hr />

<pre><code class="language-C#">using UnityEngine;
using UnityEditor;
[CustomEditor(typeof(Demo3))]
public class Demo3Inspector : Editor 
{
  public override void OnInspectorGUI()
  {
    DrawDefaultInspector ();
    Demo3 myTarget = (Demo3)target;
    if (GUILayout.Button (&quot;Crear Datos&quot;)) 
    {
      myTarget.dataA = ScriptableObject.CreateInstance&lt;Demo3Data&gt; ();
      myTarget.dataB = myTarget.dataA;
    }
  }
}
</code></pre>

<hr />

<p>Crea una nueva escena y adjunta el script Demo3 a un objeto. A diferencia de Demo1, el script Demo3 no creará automáticamente nuevas instancias del objeto Scriptable con solo mirar el script en el inspector. Para comenzar a jugar con datos, haga clic en el botón &ldquo;Crear datos compartidos&rdquo;. Ahora, ambos campos muestran el objeto de datos en si mismo. Podríamos personalizar aún más el script del editor para que se vea similar a Demo1 si así lo desea, pero por ahora no es necesario. Para editar el valor del objeto compartido, haga doble clic en el objeto de datos en cualquier campo. La ventana del inspector se actualizará mostrando solo el objeto que está editando.</p>

<p>Ahora, para la gran prueba, ¿puede esta versión sobrevivir a una recarga de ensamblaje? Continúa e ingresa y luego sal del modo de reproducción. Intente editar el valor de cualquier objeto de datos. Luego regrese y abra el objeto a través del otro campo. ¡Debería ver que la referencia se serializó correctamente, porque tendrá el mismo valor! Unity pudo retener la referencia compartida en lugar de tener que serializar una copia completa del objeto para cada campo.</p>

<h2 id="objetos-scriptables-en-tiempo-de-ejecución">Objetos Scriptables en tiempo de ejecución</h2>

<p>He mostrado los objetos de script utilizados tanto en el modo de edición como durante el modo de reproducción. Sin embargo, vale la pena señalar que algunos de los mayores beneficios de los objetos programables, en particular su fácil serialización, no es algo que pueda utilizar en tiempo de ejecución.</p>

<p>Aún puede guardar datos, como mediante el uso de JsonUtility para convertir sus objetos programables en JSON. El resultado podría guardarse de varias maneras, por ejemplo, escribiendo el valor en PlayerPrefs o escribiendo un archivo en el disco. Desafortunadamente, es probable que termine con los mismos desafíos de serialización demostrados en mis dos primeras demos. No tendrá una manera fácil de conservar referencias de objeto, ni tendrá una manera fácil de volver a crear matrices de objetos polimórficos.</p>

<p>Los Objetos Scriptables son excelentes pequeños contenedores de datos. Se pueden usar en tiempo de ejecución o editar e incluso se pueden guardar como recursos del proyecto. Ofrecen varios beneficios que los objetos estándar y las clases se pierden, como la correcta serialización, pero no son perfectos. Creo que su interfaz podría ser más intuitiva, y personalmente no me gusta la restricción de tener que heredar de ScriptableObject o de no poder usar un constructor estándar. En general, vale la pena dedicarles un poco de tiempo porque pueden proporcionar algunos flujos de trabajo convenientes y pueden ayudarlo a proyectar rápidamente su contenido.</p>

<p><center><a href="http://bit.ly/2B6sUdP" class="button">GitHub Source</a></center></p>

<p>.\Moon</p>


		
	</section>
    </div>

    <footer class="site-footer">
	<p class="text">&copy; 2022 - Moon Antonio</p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-89564434-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
