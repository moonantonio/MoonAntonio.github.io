<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>Estudio de UNET&middot; Antonio Moon´s</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Moon Antonio">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Antonio,Dev,Game">
	<meta name="generator" content="Hugo 0.50" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://moonantonio.github.io/css/main.css">
	<link id="dark-mode-theme" rel="stylesheet" href="/css/dark.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://moonantonio.github.io/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="site-header">
	<div class="branding">
		<a href="https://moonantonio.github.io/">
		<img class="avatar" src="https://moonantonio.github.io/img/avatar.png" alt="avatar"/>
		</a>
		<h1 class="site-title">
			<i class="fa fa-angle-right"></i>
			<a href="https://moonantonio.github.io/">Antonio Moon´s</a>
			<span class="logo-cursor "></span>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			<li><a href="/about/">  </a></li>

			<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/devblog/" title="devBlog">
  		</i>&nbsp; devBlog</a> <i class="fa fa-gamepad" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/backdoor" title="backDoor">
  		</i>&nbsp; backDoor</a> <i class="fa fa-black-tie" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://github.com/MoonAntonio/rec.repos" title="src">
  		</i>&nbsp; src</a> <i class="fa fa-code" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/portfolio/" title="moon">
  		</i>&nbsp; moon</a> <i class="fa fa-terminal" aria-hidden="true"></i>
  </a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="&#43;">
		</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
	</a>
</li>





<li>
	<a href="mailto:antoniomt.moon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>











<li>
	<a href="https://github.com/MoonAntonio" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























<li>
	<a href="https://gitlab.com/MoonAntonio" title="Gitlab">
		<i class="fa fa-fw fa-gitlab"></i>
	</a>
</li>

<li>
	<a href="https://trello.com/antoniomoon" title="Trello">
		<i class="fa fa-fw fa-trello"></i>
	</a>
</li>



			<a id="dark-mode-toggle" class="fa fa-moon-o" title="darkmode"></a>
		</ul>
	</nav>
</header>

    <div class="content">
    <script src="https://moonantonio.github.io/js/darkmode.js"></script>
	<article class="feature-image">
		<header style="background-image: url('https://moonantonio.github.io/img/b/b049.jpg')">
			<h1 class="title">Estudio de UNET</h1>
		</header>

	<section class="post-content">
		

<p>Esta entrada, es un recordatorio personal, después de hablar con amigos y de hablarme tan bien de UNET (Yo solo toque NET en Unity 3.5, :S), me entro el gusanico de ver esta nueva tecnología, por lo que decidí ponerme a investigar, pero descubrí que hay muy poca información sobre esto.</p>

<p>Detallo en más profundidad, <strong>hay información, pero del High API</strong>. Lo que yo quería ver es información sobre el Low API y de esto hay poco, asi que decidí crear esta entrada para guardar como recuerdo este estudio, por si próximamente tengo que volver a mirarlo (soy un neurótico del guardado de datos xD).</p>

<p>También agradecer a <strong>Alejandro Rivas y Fernando Galán</strong> por la ayuda e info que me dieron con libros y artículos.</p>

<h1 id="conceptos-necesarios">Conceptos necesarios</h1>

<p>Un <strong>sistema de red</strong> en videojuegos implica que los <strong>participantes pueden jugar juntos a través de la conexión entre ellos</strong> por medio de una red, ya sea una red de área local o el Internet. Esto quiere decir que uno o varios clientes se conectan a un servidor, para intercambiar datos.</p>

<hr />

<p><center><img src="/img/c/unet.png" alt="001" /></center></p>

<hr />

<p>En esencia, un <strong>cliente le dice al servidor lo que esta realizando y el servidor remite la información para todos los clientes</strong>, sincronizando sus estados. Este método se realiza desde cada cliente, haciendo asi que todos los clientes sean sincronizados por el servidor.</p>

<hr />

<p><center><img src="/img/c/unet2.png" alt="002" /></center></p>

<hr />

<p>Se le suele llamar a un servidor, <strong>servidor dedicado, ya que solo efectúa el cambio de datos y no ejecuta ninguna instancia</strong>. Pero también existen otros tipos de servidores. Por ejemplo en Warcraft 3, cualquier cliente puede crear una partida desde su cliente, esto realmente es levantar un servidor para que otros jugadores puedan conectar con el como clientes, a la vez, el servidor también podrá ser un cliente.</p>

<hr />

<p><center><img src="/img/c/unet3.png" alt="003" /></center></p>

<hr />

<p>Incluso se puede implementar una capa más, comúnmente llamada <strong>matchmaker</strong>, que es la instancia de un servidor que congrega las partidas de otros servidores, de esta forma los clientes conectan con el servidor principal, que este a su vez conecta con los demás servidores.</p>

<hr />

<p><center><img src="/img/c/unet4.png" alt="004" /></center></p>

<hr />

<h1 id="empezamos-el-planteamiento">Empezamos el planteamiento</h1>

<p><img src="/img/c/unet5.png" align="right" alt="Info" width="484" height="340"></p>

<p>Como siempre al final de la entrada dejo el <strong>link del repositorio en Github</strong> para los que quieran descargarlo. Doy por sentado que ya conocéis Unity y tenéis un conocimiento sobre su funcionamiento.</p>

<p>Lo primero que necesitaremos, sera un <strong>Manager para gestionar toda la información de nuestro servidor</strong>. Este Manager no puede desaparecer nunca, ya que si lo hace, el servidor y todas las <strong>conexiones se caerán</strong>.</p>

<p>Crearemos un objeto vació y le agregaremos el componente <strong>Network Manager que sera nuestro objeto para administrar la red</strong>.</p>

<hr />

<p>Este componente nos proporcionara mucha funcionalidad necesaria que podríamos escribirla desde cero pero ya que esta y no buscamos un sistema mega optimizado vamos a usarlo. Este componente ya lleva un valor booleano<strong>(Dont destroy on load)</strong> para decirle si queréis que el objeto sea destruido o que no se destruya nunca. También dispone de otro valor<strong>(Run in Background)</strong> para decidir si se ejecutara en segundo plano, Unity si no tiene este valor activado, al salir de Unity o del juego, se queda sin el foco y por lo tanto se pausa, esto seria malo si queremos que nuestros clientes reciban la información a tiempo.</p>

<p><img src="/img/c/unet6.png" align="left" alt="Info" width="484" height="76"></p>

<p>Ahora vamos a agregarle un nuevo componente, llamado <strong>Network Manager HUD</strong>. Este componente nos facilita una <strong>interfaz con la funcionalidad necesaria</strong> para conectar con un servidor, levantar nuestro servidor o activar un matchmaker.</p>

<hr />

<p>Si construimos ahora mismo la aplicación, veremos como podemos crear dos o tres instancias de Unity y con ello poder conectarlas entre ellas.</p>

<p>Ahora que ya tenemos un administrador de red, tenemos que ver en sus opciones <strong>spawn info</strong>, una opción de player prefab. Esto nos indica que este cliente tiene que instanciar algo. Pero no se refiere a algo físico, sino que tiene que tener una instancia de jugador en memoria. Digamos que la siguiente manera como vemos en la siguiente imagen.</p>

<hr />

<p><center><img src="/img/c/unet7.png" alt="007" /></center></p>

<hr />

<p>Cada jugador tiene que tener una <strong>presencia no física</strong>, es decir, pongamos el objeto que ponéis como spawn, es un objeto que posteriormente es destruido o desactivado, esto quitaría la presencia del cliente en el servidor, por que no tiene ninguna instancia. Por ello tenemos que realizar una buena praxis.</p>

<p>Creamos un objeto vació, <strong>que contendrá la información persistente del cliente/usuario</strong> y le <strong>agregaremos el componente network identity</strong>, que es un componente para obtener la identificación del objeto en la red. Luego crearemos su prefab y la agregaremos al prefab del spawn. Básicamente es un puntero a nuestro objeto de red.</p>

<p>Esto realiza más fácil la relación amor odio de nuestros clientes/servidor.</p>

<hr />

<blockquote>
<p><strong><em>Representación Dramática</em></strong></p>

<ul>
<li>Cliente : El jugador 18 tiene que moverse 3 pixeles a la derecha</li>
<li>Servidor : Sincronizando &hellip;</li>
<li>Cliente : Gracias</li>
</ul>
</blockquote>

<hr />

<p><center><img src="/img/c/unet8.png" alt="008" /><img src="/img/c/unet9.png" alt="009" /></center></p>

<hr />

<p>Ahora tenemos un pequeño problema. Si comprobamos cuando iniciamos dos instancias o mas, <strong>cada jugador instancia el mismo objeto</strong>. Vamos a cambiar eso.
He creado un script y se lo he agregado a nuestro prefab de player.</p>

<p>Empezaremos por sincronizar la instancia física del jugador, en nuestro caso un cubo con todas sus caras y vértices.</p>

<pre><code class="language-C#">//                                  ┌∩┐(◣_◢)┌∩┐
//                                                                              \\
// Player.cs (16/07/2018)                                                       \\
// Autor: Antonio Mateo (.\Moon Antonio)    antoniomt.moon@gmail.com            \\
// Descripcion:     Controller del jugador/Cliente.                             \\
// Fecha Mod:       16/07/2018                                                  \\
// Ultima Mod:      Version Inicial                                             \\
//******************************************************************************\\

#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    /// &lt;summary&gt;
    /// &lt;para&gt;Controller del jugador/Cliente.&lt;/para&gt;
    /// &lt;/summary&gt;
    public class Player : MonoBehaviour 
    {
        #region Variables Publicas
        /// &lt;summary&gt;
        /// &lt;para&gt;Prefab del cubo para instanciar.&lt;/para&gt;
        /// &lt;/summary&gt;
        public GameObject prefabCubo;
        #endregion

        #region Inicializadores
        /// &lt;summary&gt;
        /// &lt;para&gt;Inicializador de &lt;see cref=&quot;Player&quot;/&gt;.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void Start()
        {
            Instantiate(prefabCubo);
        }
        #endregion
    }
}
</code></pre>

<p>Solo tenéis que crear un gameobject, como el modelado o cualquier cubo como el nuestro y veréis su funcionamiento. Como vemos, <strong>esto es lo que realizaríamos si queremos crear un objeto en un single player</strong>, sin necesidad de ser multijugador, ahora vamos a realizar los cambios para poder crear la red.</p>

<p>Primero agregaremos <strong>using UnityEngine.Networking;</strong> y heredaremos nuestro script de <strong>NetworkBehaviour</strong> en vez de <strong>MonoBehaviour</strong>. Con esto lo que conseguimos es obtener acceso a la funcionalidad Net de Unity.</p>

<pre><code class="language-C#">private void Start()// Inicializador de Player
{
    // Comprobamos si es el objeto local
    if (!isLocalPlayer)
    {
        // Este objeto es de otro jugador
        return;
    }

    // Solo instanciara el cubo si es Local. Es decir, si soy el cliente.
    Instantiate(prefabCubo);
}
</code></pre>

<p>De esta manera, si el objeto no es nuestro, no instanciaremos nada, ya que no es nuestra autoridad. Solo podemos darle autoridad sobre los clientes al servidor. Los demás clientes no tienen que tener autoridad sobre ningún cliente que no sea el suyo propio.</p>

<hr />

<p><center><img src="/img/c/unet10.png" alt="010" /></center></p>

<hr />

<p>Bien, ahora con todo esto, tenemos que aprender unos nuevos conceptos. ¿Por que la instanciacion debe de realizarse desde el cliente? En realidad no, debería realizarse desde el servidor. Vamos a ver esto en mas profundidad.</p>

<p>En el método Start(), donde teníamos la instanciacion de nuestra unidad, deberíamos borrarla y colocar lo siguiente.</p>

<pre><code class="language-C#">// Decir al servidor que instancie nuestra unidad
CmdSpawnUnidad();
</code></pre>

<p>Simplemente indicamos que se llame a un método, lo interesante viene en ese método. <strong>Una nota antes de seguir, es ver que el prefijo del método es <code>Cmd</code></strong>, esto es una decisión que se tomo por parte de Unity3D, no se bien por que, pero es un protocolo a seguir si no quieres que te de un error. Todos los métodos que sean llamados desde el servidor deberán llevar el prefijo <strong>Cmd</strong>.</p>

<pre><code class="language-C#">/// &lt;summary&gt;
/// &lt;para&gt;Le dice al servidor que instancie la unidad.&lt;/para&gt;
/// &lt;/summary&gt;
[Command]
private void CmdSpawnUnidad()
{
    GInstantiate(prefabCubo);
}
</code></pre>

<p>Ahora en nuestro método, vemos como colocamos el atributo [Command], esto indica, que este método sera ejecutado por el servidor, en vez de por nuestro cliente. Por lo que creara el objeto y lo propagara hasta los clientes.</p>

<p><img src="/img/c/unet11.png" align="right" alt="Info" width="488" height="160"></p>

<p>Al ejecutar os dará un error, esto es por que nuestro objeto Unidad, no tiene un identificador de red, es decir el componente NetworkIdentity. Todos los objetos que van a ser modificados por la red, tienen que tener un identificador.</p>

<p>También todos los objetos tienen que ser agregados en <strong>Registered Spawnable Prefabs</strong>.</p>

<hr />

<p>Después tenemos un atributo muy peculiar que puede ser agregado a las variables que necesiten que se sincronicen desde el servidor hasta los clientes. Este atributo es <strong>[SyncVar]</strong>.</p>

<pre><code class="language-C#">/// &lt;summary&gt;
/// &lt;para&gt;Nombre del player.&lt;/para&gt;
/// &lt;/summary&gt;
[SyncVar] public string nombre = &quot;name&quot;;
</code></pre>

<p>Ahora tenemos que usar el atributo <strong>RPC</strong>, que lo que realiza es que cuando llama el servidor a este método, es ejecutado en todos los clientes. Cuando usamos este atributo, también hay que modificar el prefijo con Rpc.</p>

<pre><code class="language-C#">/// &lt;summary&gt;
/// &lt;para&gt;Cambia el nombre del jugador.&lt;/para&gt;
/// &lt;/summary&gt;
/// &lt;param name=&quot;newNombre&quot;&gt;&lt;/param&gt;
[ClientRpc]
public void RpcCambiarNombre(string newNombre)// Cambia el nombre del jugador
{
    nombre = newNombre;
}
</code></pre>

<p>De momento eso es lo principal para poder crear las conexiones entre clientes y servidores. Animo a todo el mundo a descubrir esta especie de magia que seguro que os encantara como al 100% de la gente que aprende y terminareis construyendo e investigando mas y mas. Un saludo.</p>

<p>PD: Hay mucha mas info y cosillas que explicar, pero eso sera otra historia.</p>

<hr />

<p><center><a href="https://github.com/MoonAntonio/UNetStudy" class="button"><i class="fa fa-github-alt"></i> GitHub</a></center></p>

<p><center><img src="/img/ref.png" alt="001" /></center></p>


		
	</section>
    </div>

    <footer class="site-footer">
	<p class="text">&copy; 2022 - Moon Antonio</p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'G-V17LGH4N3N', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
