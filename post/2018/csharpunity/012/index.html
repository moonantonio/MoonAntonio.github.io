<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>Aprende C# con Unity - Scriptable Objects&middot; Antonio Moon´s</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Moon Antonio">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Antonio,Dev,Game">
	<meta name="generator" content="Hugo 0.50" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://moonantonio.github.io/css/main.css">
	<link id="dark-mode-theme" rel="stylesheet" href="/css/dark.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://moonantonio.github.io/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="site-header">
	<div class="branding">
		<a href="https://moonantonio.github.io/">
		<img class="avatar" src="https://moonantonio.github.io/img/avatar.png" alt="avatar"/>
		</a>
		<h1 class="site-title">
			<i class="fa fa-angle-right"></i>
			<a href="https://moonantonio.github.io/">Antonio Moon´s</a>
			<span class="logo-cursor "></span>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			<li><a href="/about/">  </a></li>

			<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/devblog/" title="devBlog">
  		</i>&nbsp; devBlog</a> <i class="fa fa-gamepad" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/backdoor" title="backDoor">
  		</i>&nbsp; backDoor</a> <i class="fa fa-black-tie" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://github.com/MoonAntonio/rec.repos" title="src">
  		</i>&nbsp; src</a> <i class="fa fa-code" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/portfolio/" title="moon">
  		</i>&nbsp; moon</a> <i class="fa fa-terminal" aria-hidden="true"></i>
  </a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="&#43;">
		</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
	</a>
</li>





<li>
	<a href="mailto:antoniomt.moon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>











<li>
	<a href="https://github.com/MoonAntonio" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























<li>
	<a href="https://gitlab.com/MoonAntonio" title="Gitlab">
		<i class="fa fa-fw fa-gitlab"></i>
	</a>
</li>

<li>
	<a href="https://trello.com/antoniomoon" title="Trello">
		<i class="fa fa-fw fa-trello"></i>
	</a>
</li>



			<a id="dark-mode-toggle" class="fa fa-moon-o" title="darkmode"></a>
		</ul>
	</nav>
</header>

    <div class="content">
    <script src="https://moonantonio.github.io/js/darkmode.js"></script>
	<article class="feature-image">
		<header style="background-image: url('https://moonantonio.github.io/img/img103.png')">
			<h1 class="title">Aprende C# con Unity - Scriptable Objects</h1>
		</header>

	<section class="post-content">
		

<p>Los Objetos Scriptables son un tipo especial de objeto de datos en Unity. Tienen varios beneficios importantes, pero es posible que no funcionen de manera ideal para cada situación. En esta lección, cubriremos lo que son y cómo usarlos.</p>

<p><center><a href="https://github.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-github-alt"></i>GitHub Repo</a><a href="https://gitlab.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-gitlab"></i>GitLab Repo</a></center></p>

<h1 id="introducción-a-los-objetos-scriptables">Introducción a los Objetos Scriptables</h1>

<p>Puede pensar en un objeto programable como un objeto destinado solo a contener datos. Si ha estado utilizando clases o estructuras tradicionales de C# para objetos simples solo de datos, podría utilizarlas en su lugar. Por supuesto, usted se estará preguntando &ldquo;por qué&rdquo; le gustaría usar un Objeto Scriptable. Aquí hay algunos pros y contras:</p>

<h3 id="pros">Pros</h3>

<ol>
<li>Pueden sobrevivir a una recarga de escena (como cuando construyes tus scripts o cuando ingresas y sales del modo de reproducción).</li>
<li>Se guardan por referencia, mientras que las clases y estructuras normales se serializan como copias completas. Esto puede ayudarlo a evitar la duplicación de datos.</li>
<li>Pueden manejar el polimorfismo, mientras que las clases normales terminan siendo tratadas como la clase base.</li>
<li>Se pueden guardar como un asset del proyecto.</li>
<li>No necesitan estar adjuntos a GameObjects.</li>
</ol>

<h3 id="contras">Contras</h3>

<ol>
<li>Debe heredar de ScriptableObject, lo que puede romper muchas de sus opciones arquitectónicas o de diseño.</li>
<li>No puede crearlos usando constructores normales, sino que debe usar &ldquo;CreateInstance&rdquo; en su lugar.</li>
<li>Los beneficios de serialización no son igualmente aplicables en tiempo de ejecución.</li>
</ol>

<p>He creado varias mini ejemplos para aclarar estos puntos. Las dos primeras demostraciones muestran cómo podría encontrarse con problemas si no estuviera usando objetos. Las dos demos siguientes muestran cómo ScriptableObjects supera esos mismos problemas.</p>

<h2 id="ejemplo-1-pérdida-de-referencias-de-objeto-en-la-serialización">Ejemplo 1 :: Pérdida de referencias de objeto en la serialización</h2>

<p>Comencemos con algunos ejemplos de serialización. Comience por crear un nuevo script llamado &ldquo;Demo1&rdquo; y otro llamado &ldquo;Demo1Data&rdquo;, también agregue un script de editor llamado &ldquo;Demo1Inspector&rdquo;:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class Demo1 : MonoBehaviour 
    {
        public Demo1Data dataA;
        public Demo1Data dataB;
    }
}
</code></pre>

<hr />

<p>Este script tendrá dos copias de la misma instancia de &ldquo;Demo1Data&rdquo;. Usaremos un script editor para crear y asignar sus valores.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    [System.Serializable]
    public class Demo1Data
    {
        public int value;
    }
}
</code></pre>

<hr />

<p>Este script muestra una clase C# estándar muy simple. Se puede serializar, gracias a la etiqueta &ldquo;[System.Serializable]&ldquo;, pero Unity no lo manejará perfectamente, lo que se demostrará pronto.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using UnityEditor;
#endregion

namespace MoonAntonio
{
    [CustomEditor(typeof(Demo1))]
    public class Demo1Inspector : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();
            Demo1 myTarget = (Demo1)target;
            if (GUILayout.Button(&quot;Crear Data&quot;))
            {
                myTarget.dataA = new Demo1Data();
                myTarget.dataB = myTarget.dataA;
            }
        }
    }
}
</code></pre>

<hr />

<p>Este script proporcionará un botón en el inspector de nuestro componente que creará una nueva instancia de &ldquo;Demo1Data&rdquo; y la asignará a ambos campos en el script &ldquo;Demo1&rdquo;. IMPORTANTE : el script del editor debe agregarse a una carpeta &ldquo;Editor&rdquo; o no funcionará correctamente.</p>

<p>Adelante y crea una nueva escena. Agregue la &ldquo;Demo1&rdquo; como componente a cualquier objeto, crear un nuevo objeto de juego vacío o incluso adjuntarlo a la cámara. Luego mira en el inspector. Unity creará automáticamente nuevas instancias de &ldquo;Demo1Data&rdquo; para ambos campos simplemente mirando el objeto en el inspector. Puede asignar cualquier valor que desee a cada uno de los campos &ldquo;value&rdquo;. Si ingresa y sale del modo de reproducción, los valores incluso persistirán, hasta ahora todo bien.</p>

<p>Salga del modo de reproducción (si aún no lo hizo), luego use el botón &ldquo;Crear data&rdquo; en el inspector. El valor para ambos campos debería volver a &lsquo;0&rsquo; porque ambos campos ahora se refieren a la misma instancia nueva. Si modifica el campo de valor de &ldquo;dataB&rdquo;, debería ver el campo de valor de la actualización &ldquo;dataA&rdquo; para que coincida en consecuencia. Sigue luciendo bien &hellip; al menos hasta que ingrese y salga del modo de reproducción. Pruébalo, luego modifica el valor de &ldquo;dataB&rdquo; una vez más. Uh oh, ¡los dos ya no están haciendo referencia al mismo objeto! Unity ha creado una copia completa del objeto original para ambos campos.</p>

<h2 id="demo-2-pérdida-de-tipo-de-objeto-en-la-serialización">Demo 2 :: Pérdida de tipo de objeto en la serialización</h2>

<p>Esta demostración mostrará cómo Unity no puede serializar correctamente el tipo de un objeto. Puede encontrar este problema con una lista polimórfica de objetos. Crea lo siguiente:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class Demo2 : MonoBehaviour 
    {
        public Demo2Data[] dataArray;
    }
}
</code></pre>

<hr />

<p>Este script tendrá una matriz de objetos. Cada objeto compartirá una clase base - &ldquo;Demo2Data&rdquo;, pero en realidad se instanciará como una subclase.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    [System.Serializable]
    public class Demo2Data
    {
        public string name;
        public override string ToString()
        {
            return string.Format(&quot;[{0}]&quot;, name);
        }
    }

    [System.Serializable]
    public class Demo2NumberData : Demo2Data
    {
        public int number;
        public override string ToString()
        {
            return string.Format(&quot;[{0}, {1}]&quot;, name, number);
        }
    }

    [System.Serializable]
    public class Demo2BoolData : Demo2Data
    {
        public bool toggle;
        public override string ToString()
        {
            return string.Format(&quot;[{0}, {1}]&quot;, name, toggle);
        }
    }
}
</code></pre>

<hr />

<p>Aquí hay tres clases, una clase base llamada &ldquo;Demo2Data&rdquo; y dos subclases de la misma. Tenga en cuenta que nunca instanciaremos una copia de la clase base directamente.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using UnityEditor;
#endregion

namespace MoonAntonio
{
    [CustomEditor(typeof(Demo2))]
    public class Demo2Inspector : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();
            Demo2 myTarget = (Demo2)target;
            if (GUILayout.Button(&quot;Crear Data&quot;))
            {
                var dataA = new Demo2NumberData();
                dataA.name = &quot;Demo2NumberData&quot;;
                dataA.number = UnityEngine.Random.Range(1, 100);
                var dataB = new Demo2BoolData();
                dataB.name = &quot;Demo2BoolData&quot;;
                dataB.toggle = UnityEngine.Random.value &gt; 0.5;
                myTarget.dataArray = new Demo2Data[] { dataA, dataB };
            }
            if (GUILayout.Button(&quot;Log&quot;))
            {
                foreach (var data in myTarget.dataArray)
                {
                    Debug.Log(data.ToString());
                }
            }
        }
    }
}
</code></pre>

<hr />

<p>Este script proporcionará algunos botones en el inspector de nuestro componente. El primero está etiquetado como &ldquo;Crear data&rdquo; e instanciará cada una de nuestras subclases de datos y las asignará a la matriz de datos de nuestro script. El segundo botón está etiquetado como &ldquo;Log&rdquo; y hará que cada objeto en la matriz imprima sus valores en la ventana de la consola. IMPORTANTE : el script del editor debe agregarse a una carpeta &ldquo;Editor&rdquo; o no funcionará correctamente.</p>

<p>Adelante y crea una nueva escena. Agregue la &ldquo;Demo2&rdquo; como un componente a cualquier objeto del juego, como crear un nuevo objeto de juego vacío o incluso adjuntarlo a la cámara. Luego mira en el inspector. Unity creará automáticamente una matriz vacía de datos simplemente mirando el objeto en el inspector. Llenemos nuestro objeto con datos haciendo clic en el botón &ldquo;Crear datos&rdquo;. Debería ver que la matriz contiene ahora dos objetos.</p>

<p>Aunque la clase de datos base y sus subclases tienen la etiqueta &ldquo;[System.Serializable]&ldquo;, no verá los campos agregados para los campos &ldquo;number&rdquo; o &ldquo;toggle&rdquo; de las instancias reales. Esto se debe a que Unity los trata como a la clase base, que solo conoce el &ldquo;nombre&rdquo; del objeto. Sin embargo, los datos todavía están allí (al menos por el momento). Haga clic en el botón &ldquo;Log&rdquo; y debería ver la descripción completa. En una de mis propias ejecuciones vi salidas como las siguientes:</p>

<p>[Demo2NumberData, 84]</p>

<p>[Demo2BoolData, False]</p>

<p>Se ve bien hasta ahora, ¿verdad? Bueno, veamos si puede sobrevivir a una recarga de escena. Adelante, ingrese y salga del modo de reproducción. Ahora presione el botón &ldquo;Log&rdquo; una vez más. Debería ver un resultado como este:</p>

<p>[Demo2NumberData]</p>

<p>[Demo2BoolData]</p>

<p>Al igual que Unity no sabía cómo mostrar los objetos correctamente, ¡tampoco sabía cómo serializarlos correctamente! ¡Ambos objetos ahora son instancias de la clase base y se pierden sus datos de subclase!</p>

<h2 id="demo-3-las-referencias-a-objetos-scriptable-sobreviven-a-la-serialización">Demo 3 :: Las referencias a objetos Scriptable sobreviven a la serialización</h2>

<p>Esta vez recrearemos la Demo 1, excepto que usaremos un Objeto Scriptable para nuestros datos serializados en lugar de una clase C# estándar. Crea lo siguiente:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class Demo3 : MonoBehaviour 
    {
        public Demo3Data dataA;
        public Demo3Data dataB;
    }
}
</code></pre>

<hr />

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    [System.Serializable]
    public class Demo3Data : ScriptableObject
    {
        public int value;
    }
}
</code></pre>

<hr />

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using UnityEditor;
#endregion

namespace MoonAntonio
{
    [CustomEditor(typeof(Demo3))]
    public class Demo3Inspector : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();
            Demo3 myTarget = (Demo3)target;
            if (GUILayout.Button(&quot;Crear Data&quot;))
            {
                myTarget.dataA = ScriptableObject.CreateInstance&lt;Demo3Data&gt;();
                myTarget.dataB = myTarget.dataA;
            }
        }
    }
}
</code></pre>

<hr />

<p>Crea una nueva escena y adjunta el script Demo3 a un objeto. A diferencia de Demo1, el script Demo3 no creará automáticamente nuevas instancias del objeto Scriptable con solo mirar el script en el inspector. Para comenzar a jugar con datos, haga clic en el botón &ldquo;Crear data&rdquo;. Ahora, ambos campos muestran el objeto de datos en si mismo. Podríamos personalizar aún más el script del editor para que se vea similar a Demo1 si así lo desea, pero por ahora no es necesario. Para editar el valor del objeto compartido, haga doble clic en el objeto de datos en cualquier campo. La ventana del inspector se actualizará mostrando solo el objeto que está editando.</p>

<p>Ahora, para la gran prueba, ¿puede esta versión sobrevivir a una recarga de escena? Continúa e ingresa y luego sal del modo de reproducción. Intente editar el valor de cualquier objeto de datos. Luego regrese y abra el objeto a través del otro campo. ¡Debería ver que la referencia se serializó correctamente, porque tendrá el mismo valor! Unity pudo retener la referencia compartida en lugar de tener que serializar una copia completa del objeto para cada campo.</p>

<h2 id="demo-4-el-tipo-de-objeto-scriptable-sobrevive-a-la-serialización">Demo 4 :: El tipo de objeto Scriptable sobrevive a la serialización</h2>

<p>Ahora recreemos Demo 2 (la demostración de polimorfismo) al usar objetos programables en lugar de objetos C# estándar. Tenga en cuenta que en la demostración 2, el objeto de datos base y sus subclases compartieron un solo archivo de script. Unity tiene algunos requisitos adicionales tales que cada objeto programable debe aparecer en su propio archivo y el nombre del archivo debe coincidir con el nombre de la clase.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class Demo4 : MonoBehaviour 
    {
        public Demo4Data[] dataArray;
    }
}
</code></pre>

<hr />

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class Demo4Data : ScriptableObject
    {
        public override string ToString()
        {
            return string.Format(&quot;[{0}]&quot;, name);
        }
    }
}
</code></pre>

<hr />

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class Demo4NumberData : Demo4Data
    {
        public int number;
        public override string ToString()
        {
            return string.Format(&quot;[{0}, {1}]&quot;, name, number);
        }
    }
}
</code></pre>

<hr />

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class Demo4BoolData : Demo4Data
    {
        public bool toggle;
        public override string ToString()
        {
            return string.Format(&quot;[{0}, {1}]&quot;, name, toggle);
        }
    }
}
</code></pre>

<hr />

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using UnityEditor;
#endregion

namespace MoonAntonio
{
    [CustomEditor(typeof(Demo4))]
    public class Demo4Inspector : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();
            Demo4 myTarget = (Demo4)target;
            if (GUILayout.Button(&quot;Crear Data&quot;))
            {
                var dataA = ScriptableObject.CreateInstance&lt;Demo4NumberData&gt;();
                dataA.name = &quot;Demo4NumberData&quot;;
                dataA.number = UnityEngine.Random.Range(1, 100);
                var dataB = ScriptableObject.CreateInstance&lt;Demo4BoolData&gt;();
                dataB.name = &quot;Demo4BoolData&quot;;
                dataB.toggle = UnityEngine.Random.value &gt; 0.5;
                myTarget.dataArray = new Demo4Data[] { dataA, dataB };
            }
            if (GUILayout.Button(&quot;Log&quot;))
            {
                foreach (var data in myTarget.dataArray)
                {
                    Debug.Log(data.ToString());
                }
            }
        }
    }
}
</code></pre>

<hr />

<p>Continúa y crea una nueva escena, luego adjunta el script Demo4 a cualquier objeto. Utilice el script del inspector para &ldquo;Crear datos&rdquo; en nuestro componente Demo4. Al igual que en Demo3, debe hacer doble clic en el campo del objeto para ver y editar los valores de cada instancia del objeto. Use el botón &ldquo;Log&rdquo; para ver rápidamente cada ventana impresa en la consola.</p>

<p>Ahora, para la gran prueba, ¿puede esta versión sobrevivir a una recarga de escena? Continúa e ingresa y luego sal del modo de reproducción. Presione el botón &ldquo;Log&rdquo; una vez más. ¡Éxito!</p>

<h2 id="demo-5-assets-scriptable-object">Demo 5 :: Assets Scriptable Object</h2>

<p>Dije que podías guardar estos objetos como assets, y también mencioné repetidamente que los Objetos Scriptables no se adjuntan a GameObjects, sin embargo, en cada demostración hasta el momento solo los he mostrado como referencias en scripts de MonoBehaviour. En esta lección, finalmente mostraré cómo trabajar con estos objetos de datos por su cuenta.</p>

<p>Solía ​​ser un proceso más engorroso para crear Objetos Scriptables, pero ahora tenemos una etiqueta llamada &ldquo;CreateAssetMenu&rdquo; que lo maneja automáticamente para nosotros. Puedes comenzar con algo tan simple como:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    [CreateAssetMenu()]
    public class ScriptableTets : ScriptableObject
    {
        public int value;
    }
}
</code></pre>

<hr />

<p>Compila tu código y regresa a Unity. Puede usar la barra de menú de la aplicación (Assets -&gt; Create -&gt; ScriptableTets), o el menú desplegable &ldquo;Create&rdquo; del panel Proyecto (Create -&gt; ScriptableTets). Seleccione uno y se creará un nuevo activo en su proyecto llamado &ldquo;New ScriptableTets&rdquo;. Puede cambiar el nombre del activo, moverlo a otra carpeta, rellenarlo con los datos personalizados, etc. Guarde el proyecto y ahora tiene una aplicación práctica del asset.</p>

<p>El &ldquo;CreateAssetMenu&rdquo; también puede tomar parámetros. En la siguiente versión, especifico el nombre de las instancias recientemente creadas, hago que aparezca en un submenú y especifico un orden para que pueda hacer que los objetos utilizados con mayor frecuencia aparezcan en la parte superior de la lista.</p>

<hr />

<pre><code class="language-C#">[CreateAssetMenu(fileName = &quot;ScriptableTets&quot;, menuName = &quot;Scriptable Objects/ScriptableTets&quot;, order = 1)]
</code></pre>

<hr />

<p>Si ha revisado la documentación del <a href="http://bit.ly/2MPNwfC">Scriptable Object</a> , puede haber notado que tiene algunos métodos similares en nombre a aquellos en un MonoBehaviour. Por ejemplo, tiene: Awake, OnDestroy, OnDisable y OnEnable. Como no hay GameObject, ¿cuándo se llaman? Desafortunadamente, la respuesta probablemente no sea la esperada. Agregué mensajes de registro de depuración a cada uno de estos métodos en mi clase &ldquo;ScriptableTets&rdquo;.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    [CreateAssetMenu(fileName = &quot;ScriptableTets&quot;, menuName = &quot;Scriptable Objects/ScriptableTets&quot;, order = 1)]
    public class ScriptableTets : ScriptableObject
    {
        public int value;

        void Awake()
        {
            Debug.Log(&quot;Awake ScriptableTets &quot; + name);
        }

        void OnDestroy()
        {
            Debug.Log(&quot;Destroy ScriptableTets &quot; + name);
        }

        void OnEnable()
        {
            Debug.Log(&quot;OnEnable ScriptableTets &quot; + name);
        }

        void OnDisable()
        {
            Debug.Log(&quot;OnDisable ScriptableTets &quot; + name);
        }
    }
}
</code></pre>

<hr />

<ol>
<li>Compila tus scripts. Ahora crea un nuevo assets &ldquo;ScriptableTets&rdquo;. Debería ver que se llama a &ldquo;Awake&rdquo; y luego a &ldquo;OnEnable&rdquo;, en ese orden. Esto probablemente se esperaba, si está familiarizado con el pedido de MonoBehaviour.</li>
<li>Haga clic en el activo ScriptableTets para que su nombre se aplique y deje de estar seleccionado.</li>
<li>Luego, ingrese el modo de reproducción. Debería ver que se llama &ldquo;OnDisable&rdquo;, luego se llama a &ldquo;OnEnable&rdquo; una vez más. Esto tiene que ver con la forma en que los objetos pasan entre el motor central C++ de Unity y el lado de scripting C# de Unity.</li>
<li>Salga del modo de reproducción y verá nuevamente &ldquo;OnDisable&rdquo;, pero en realidad no verá una llamada a &ldquo;OnEnable&rdquo; como podría haber esperado.</li>
<li>Si ahora selecciona el activo &ldquo;ScriptableTets&rdquo; para que aparezca en el inspector, verá una llamada &ldquo;Awake&rdquo; y otra vez &ldquo;OnEnable&rdquo;.</li>
</ol>

<p>Sin haberlo probado, habría pensado que estos métodos estaban pensados ​​para el uso en tiempo de ejecución y no serían invocados por las acciones del editor. Además, habría pensado que &ldquo;Awake&rdquo; estaría reservado para la creación del activo solamente, especialmente dado que no se nos permite usar el constructor de un Objeto Scriptable. En mi opinión, realmente debería haber algún tipo de método &ldquo;init&rdquo; que solo se llame una vez para la creación del activo. Aquí es donde normalmente agregaría trabajo de configuración para un objeto que no quisiera que ocurriera más de una vez. Para obtener el comportamiento que deseo, aún puedo usar un script editor para crear y configurar manualmente mi activo.</p>

<h1 id="objetos-scriptable-en-tiempo-de-ejecución">Objetos Scriptable en tiempo de ejecución</h1>

<p>He mostrado los objetos de script utilizados tanto en el modo de edición como durante el modo de reproducción. Sin embargo, vale la pena señalar que algunos de los mayores beneficios de los objetos programables, en particular su fácil serialización, no es algo que pueda utilizar en tiempo de ejecución.</p>

<p>Aún puede guardar datos, como mediante el uso de JsonUtility para convertir sus objetos programables en JSON. El resultado podría guardarse de varias maneras, por ejemplo, escribiendo el valor en PlayerPrefs o escribiendo un archivo en el disco. Desafortunadamente, es probable que termine con los mismos desafíos de serialización demostrados en mis dos primeras demos. No tendrá una manera fácil de conservar referencias de objeto, ni tendrá una manera fácil de volver a crear matrices de objetos polimórficos.</p>

<h1 id="resumen">Resumen</h1>

<p>Los Objetos Scriptables son excelentes pequeños contenedores de datos. Se pueden usar en tiempo de ejecución o editar e incluso se pueden guardar como recursos del proyecto. Ofrecen varios beneficios que los objetos estándar y las clases pierden, como la correcta serialización, pero no son perfectos. Creo que su interfaz podría ser más intuitiva, y personalmente no me gusta la restricción de tener que heredar de ScriptableObject o de no poder usar un constructor estándar. En general, vale la pena dedicarles un poco de tiempo porque pueden proporcionar algunos flujos de trabajo convenientes y pueden ayudarlo a prototipar rápidamente su contenido.</p>


		
	</section>
    </div>

    <footer class="site-footer">
	<p class="text">&copy; 2022 - Moon Antonio</p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-89564434-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
