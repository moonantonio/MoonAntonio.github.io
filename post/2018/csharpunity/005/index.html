<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>Aprende C# con Unity - Bucles&middot; Antonio Moon´s</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Moon Antonio">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Antonio,Dev,Game">
	<meta name="generator" content="Hugo 0.50" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://moonantonio.github.io/css/main.css">
	<link id="dark-mode-theme" rel="stylesheet" href="/css/dark.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://moonantonio.github.io/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="site-header">
	<div class="branding">
		<a href="https://moonantonio.github.io/">
		<img class="avatar" src="https://moonantonio.github.io/img/avatar.png" alt="avatar"/>
		</a>
		<h1 class="site-title">
			<i class="fa fa-angle-right"></i>
			<a href="https://moonantonio.github.io/">Antonio Moon´s</a>
			<span class="logo-cursor "></span>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			<li><a href="/about/">  </a></li>

			<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/devblog/" title="devBlog">
  		</i>&nbsp; devBlog</a> <i class="fa fa-gamepad" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/backdoor" title="backDoor">
  		</i>&nbsp; backDoor</a> <i class="fa fa-black-tie" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://github.com/MoonAntonio/rec.repos" title="src">
  		</i>&nbsp; src</a> <i class="fa fa-code" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/portfolio/" title="moon">
  		</i>&nbsp; moon</a> <i class="fa fa-terminal" aria-hidden="true"></i>
  </a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="&#43;">
		</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
	</a>
</li>





<li>
	<a href="mailto:antoniomt.moon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>











<li>
	<a href="https://github.com/MoonAntonio" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























<li>
	<a href="https://gitlab.com/MoonAntonio" title="Gitlab">
		<i class="fa fa-fw fa-gitlab"></i>
	</a>
</li>

<li>
	<a href="https://trello.com/antoniomoon" title="Trello">
		<i class="fa fa-fw fa-trello"></i>
	</a>
</li>



			<a id="dark-mode-toggle" class="fa fa-moon-o" title="darkmode"></a>
		</ul>
	</nav>
</header>

    <div class="content">
    <script src="https://moonantonio.github.io/js/darkmode.js"></script>
	<article class="feature-image">
		<header style="background-image: url('https://moonantonio.github.io/img/b/b002.jpg')">
			<h1 class="title">Aprende C# con Unity - Bucles</h1>
		</header>

	<section class="post-content">
		

<p>Como programador, con frecuencia trabajará con un &ldquo;grupo&rdquo; de datos (como una matriz o array que presenté en la lección anterior). Tic Tac Toe, por ejemplo, tiene un tablero de 3 × 3 con nueve celdas totales. Si estuviera creando un método para operar en ese grupo de datos, como limpiar un tablero para un nuevo juego, no querría tener que aplicar manualmente los cambios a todos y cada uno de los valores de la matriz. En cambio, puede escribir algo llamado bucle y dejar que la maquina maneje el trabajo tedioso por usted. En esta lección, crearemos un Tic Tac Toe y mostraremos cómo los bucles pueden ayudar a que nuestro código sea más elegante.</p>

<p><center><a href="https://github.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-github-alt"></i>GitHub Repo</a><a href="https://gitlab.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-gitlab"></i>GitLab Repo</a></center></p>

<h1 id="la-vida-sin-bucles">La vida sin bucles</h1>

<p>Crea un nuevo script llamado &ldquo;TicTacToe&rdquo;. Sin bucles, puede tratar de implementar este juego con algo como lo siguiente:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
#endregion

namespace MoonAntonio
{
    public class TicTacToe : MonoBehaviour 
    {
        [SerializeField] Text[] cells;

        void Start()
        {
            NewGame();
        }

        public void NewGame()
        {
            cells[0].text = &quot;&quot;;
            cells[1].text = &quot;&quot;;
            cells[2].text = &quot;&quot;;
            cells[3].text = &quot;&quot;;
            cells[4].text = &quot;&quot;;
            cells[5].text = &quot;&quot;;
            cells[6].text = &quot;&quot;;
            cells[7].text = &quot;&quot;;
            cells[8].text = &quot;&quot;;
            cells[9].text = &quot;&quot;;
        }
    }
}
</code></pre>

<hr />

<p>Este código declara una matriz de componentes de texto que representan las celdas de nuestro tablero de tres en raya. También define el primer método que necesitaremos, uno que despeje el tablero para prepararlo para un nuevo juego. En ese método asignamos el texto de cada celda a una cadena vacía para que la celda no se use. Todo lo escrito aquí hasta ahora es funcional, pero no elegante, o fácilmente ampliable para juegos con tableros más grandes. ¡Imagine una configuración similar para Ajedrez, donde tiene que asignar manualmente 64 fichas en lugar de las 9 que tenemos aquí!</p>

<h1 id="la-magia-de-los-bucles">La magia de los bucles</h1>

<p>Cada una de las nueve afirmaciones en el método NewGame es idéntica a una excepción, el índice de la celda en la matriz. Como programador, a menudo escuchará acerca de mantener su código &ldquo;DRY&rdquo;, lo que significa &ldquo;No repetir&rdquo;. Esto a menudo puede referirse a la necesidad de poner bits de lógica en métodos más reutilizables y más pequeños, pero también puede aplicarse aquí. Mira cómo el método NewGame podría implementarse con un nuevo vocabulario:</p>

<hr />

<pre><code class="language-C#">public void NewGame()
{
    for (int n = 0; n &lt; cells.Length; n++)
    {
        cells[n].text = &quot;&quot;;
    }
}
</code></pre>

<hr />

<p>En este ejemplo, pudimos reemplazar nueve declaraciones separadas del método &ldquo;NewGame&rdquo; con una sola declaración envuelta en un &ldquo;for loop&rdquo;. Además de ser más compacto, este código recortado también es dinámico y ampliable. ¡Podríamos cambiar de un tablero de tres en raya estándar de 3 x 3 pies a un tablero de 5 x 5 y no necesitar cambiar ni agregar ninguna línea de código, mientras que la implementación anterior habría requerido 16 líneas adicionales!</p>

<p>La palabra clave &ldquo;for&rdquo; marca el comienzo de nuestro ciclo. Un inicializador, una condición y una &ldquo;expresión&rdquo; de iterador aparecen dentro de sus paréntesis (tenga en cuenta que están separados por punto y coma, pero el último no termina con un punto y coma), y un cuerpo (los enunciados que se ejecutarán repetidamente) aparecerán entre el abierto y cerrar corchetes &lsquo;{&rsquo; y &lsquo;}&rsquo;.</p>

<p>Las declaraciones dentro del paréntesis determinan las &ldquo;reglas&rdquo; de cómo bucleamos y merecemos un poco más de discusión:</p>

<ul>
<li>Declaro una variable temporal llamada &ldquo;n&rdquo; en la declaración &ldquo;inicializador&rdquo; y asigno su valor predeterminado a 0. El alcance de esta variable está restringido al bucle en sí, y no será visible fuera de su declaración y cuerpo. El inicializador solo se ejecuta una vez, al comienzo de este bloque de código.</li>
<li>La &ldquo;condición&rdquo; determina si se ejecuta el código en su cuerpo o no. En este ejemplo, continuaremos iterando mientras el valor de &ldquo;n&rdquo; sea menor que la longitud de nuestra matriz de celdas. Esta afirmación se comprueba una vez antes de cada ciclo de ciclo.</li>
<li>El &ldquo;iterador&rdquo; nos brinda la oportunidad de modificar la variable que declaramos en el inicializador. En este ejemplo, incrementamos el valor de &ldquo;n&rdquo; en uno después de cada ciclo. Tenga en cuenta que &ldquo;n++&rdquo; es una forma abreviada de escribir &ldquo;n = n + 1&rdquo;. El iterador se ejecuta después de cada ciclo.</li>
</ul>

<p>En el cuerpo de nuestro bucle, pasamos la variable &ldquo;n&rdquo; que definimos en el inicializador de bucle, como el índice en nuestra matriz de celdas. Al usar la variable, la celda que estamos modificando es dinámica y será diferente en cada ejecución a través del ciclo.</p>

<hr />

<h3 id="consejo">Consejo:</h3>

<ul>
<li>Hay funciones adicionales del bucle for, como no proporcionar una o más reglas para su bucle. Ver la <a href="http://bit.ly/2PxJBBY">referencia para más</a>.
Hay muchos otros tipos de bucles en C#. Normalmente uso el ciclo &ldquo;while&rdquo;, aunque tiendo a evitar el ciclo &ldquo;foreach&rdquo; debido a <a href="https://ubm.io/2PAxDaO">problemas de memoria en Unity</a>.</li>
</ul>

<hr />

<h1 id="interacción">Interacción</h1>

<p>Ahora que tenemos un tablero y podemos prepararla para jugar, agreguemos algo de lógica para jugar. Necesitaremos dos cosas: una variable que marque si es hora de colocar una &ldquo;X&rdquo; o una &ldquo;O&rdquo; y un método de manejo de eventos para determinar cuándo y dónde hacer un movimiento en el tablero. Agregue la siguiente declaración de variable debajo de nuestra matriz de celdas:</p>

<hr />

<pre><code class="language-C#">string marca;
</code></pre>

<hr />

<p>Hagamos que las X siempre vayan primero. Para hacer eso, agregue la siguiente instrucción dentro del método NewGame, justo después del corchete de cierre de nuestro ciclo:</p>

<hr />

<pre><code class="language-C#">marca = &quot;X&quot;;
</code></pre>

<hr />

<p>Cuando el usuario haga clic en uno de los botones de nuestro tablero, necesitaremos un método para que llame. Eso se definirá de la siguiente manera:</p>

<hr />

<pre><code class="language-C#">public void SelectCell(int index)
{
    if (!string.IsNullOrEmpty(cells[index].text)) return;

    cells[index].text = marca;
    marca = (marca == &quot;X&quot;) ? &quot;O&quot; : &quot;X&quot;;
}
</code></pre>

<hr />

<p>Este método comienza con un control para ver si la celda ya se ha marcado o no (porque no queremos permitir que un jugador sobrescriba el movimiento de otro jugador). El signo de exclamación significa &ldquo;No&rdquo;, por lo que toda la afirmación se lee básicamente &ldquo;si el texto de la celda no está vacío&rdquo;. Cuando la condición es verdadera, el método llama a una declaración de &ldquo;retorno&rdquo; para que el resto del método sea ignorado. Tenga en cuenta que este ejemplo no ajusta la declaración de retorno entre corchetes. Los corchetes solo son necesarios cuando necesita más de una declaración para ser tratada como el cuerpo. Normalmente, solo usaría una declaración de devolución al final de un método, pero ocasionalmente la verá al comienzo de un método como una forma de &ldquo;abortar&rdquo; anticipadamente.</p>

<p>Cuando la condición es falsa, el resto del método se puede ejecutar normalmente. En este caso, significa que la celda está vacía y, por lo tanto, es un lugar legal para realizar un &ldquo;movimiento&rdquo;. Hacemos nuestro &ldquo;movimiento&rdquo; asignando el valor de &ldquo;marca&rdquo; a la etiqueta.</p>

<p>Finalmente, cambiamos las curvas al alternar la marca de X a O y viceversa. Esta afirmación puede considerarse como una variación de una &ldquo;declaración if&rdquo;. Tiene una condición (el código entre paréntesis) seguido de un signo de interrogación. Si el resultado de la condición es verdadero, se usa el valor a la izquierda de los dos puntos, de lo contrario se usa el valor a la derecha de los dos puntos. Para ver lo que tenemos hasta ahora, comencemos a construir la escena.</p>

<h1 id="configuración-de-escena">Configuración de escena</h1>

<ol>
<li>Para comenzar, crea una nueva escena llamada &ldquo;TicTacToe&rdquo; (En el repositorio es la 05).</li>
<li>Agregue un nuevo Panel (desde la barra de menú, seleccione &ldquo;GameObject -&gt; UI -&gt; Panel&rdquo;).</li>
<li>Elimine los componentes &ldquo;Image&rdquo; y &ldquo;Canvas Renderer&rdquo; de ese panel (seleccione el engranaje en el inspector y luego &ldquo;Eliminar componente&rdquo;) porque no los necesitaremos.</li>
<li>En el componente &ldquo;Rect Transform&rdquo; del panel, ingrese un valor de &ldquo;0.5&rdquo; para cada uno de los cuatro anclajes (Mín. Y Máx., X e Y), así como también el Pivot (X e Y). Establezca la Posición en cero en los tres ejes (X, Y y Z) y configure el Ancho y la Altura en &ldquo;300&rdquo;.</li>
<li>Agregue el componente &ldquo;Grid Layout Group&rdquo; (en la barra de menú, seleccione “Component -&gt; Layout -&gt; Grid Layout Group”). Establezca su tamaño de celda en 100 para X e Y.</li>
<li>Agregue un botón (desde la barra de menú elija &ldquo;GameObject -&gt; UI -&gt; Button&rdquo;) y créelo en el panel (arrástrelo y suéltelo encima del objeto Panel en el panel de jerarquía para que quede anidado debajo).</li>
<li>Duplique el botón hasta que tenga nueve botones en total (desde la barra de menú, seleccione &ldquo;Edit -&gt; Duplicate&rdquo; o Ctrl + D). Si ha seguido correctamente los pasos, debería ver una placa de botones 3 × 3 centrada en el centro de la cámara.</li>
<li>Adjunte nuestro script de TicTacToe al canvas.</li>
<li>Asegúrese de que el canvas esté seleccionado y luego bloquee el inspector (haga clic en el ícono de candado en la esquina superior derecha).</li>
<li>Expanda cada uno de los botones en la jerarquía para que pueda ver las etiquetas de texto. Multi-selecciona los objetos de texto, y arrástrelos a la variable de matriz de celdas de nuestro script. Unity cambiará automáticamente el tamaño de la matriz para contener todos los valores y asignar los objetos a la matriz.</li>
<li>Cuando se hayan asignado todas las celdas, desbloquee el inspector.</li>
<li>Contraiga los botones en la jerarquía y luego seleccione varios botones. Use el inspector para agregar un controlador OnClick. Arrastre el objeto Canvas al campo del objeto de destino y seleccione &ldquo;TicTacToe -&gt; SelectCell (int)&rdquo; como nuestro controlador de función.</li>
<li>Tendrá que asignar el valor para pasar cada botón individualmente (hay formas mejores pero esto servirá por ahora) Comenzando desde arriba, establezca los valores para pasar de 0-8 (usaremos este valor como el índice en una matriz).</li>
</ol>

<p>Reproduzca la escena y haga clic en cada uno de los botones. Debería ver cada botón establecer una X o O alternando como su etiqueta al hacer clic en ellos. Si el botón en el que hace clic hace que se actualice la etiqueta de un botón diferente, entonces ha vinculado algo incorrectamente. Verifique que la matriz de etiquetas de texto esté en orden (puede hacer clic en ellas en el inspector y resaltará la coincidencia en el panel de jerarquía) de arriba a abajo. Verifique también que el parámetro OnClick del botón esté marcado en orden según el paso 13.</p>

<h1 id="estado-del-juego">Estado del juego</h1>

<p>El último paso es hacer que nuestro juego mire para una condición de victoria/derrota. Después de cada turno necesitamos hacer este control, y cuando se encuentre, felicitar al ganador y comenzar un nuevo juego.</p>

<p>Agregue otra variable que indique cuando el juego está realmente terminado. Lo usaremos para asegurarnos de que no se jugarán movimientos extra cuando se encuentre una condición de victoria. También crearemos e inicializaremos una matriz multidimensional, donde cada subarray es una lista de índices de ubicación que forman una línea en el tablero (filas, columnas y diagonales) desde la cual comprobaremos las posibles victorias. Agregue estos justo debajo de la declaración de la variable &ldquo;marca&rdquo;:</p>

<hr />

<pre><code class="language-C#">bool gameOver;
int[,] wins = new int[,]
{
    {0,1,2},
    {3,4,5},
    {6,7,8},
    {0,3,6},
    {1,4,7},
    {2,5,8},
    {0,4,8},
    {2,4,6}
};
</code></pre>

<hr />

<p>En el método NewGame, tendremos que asegurarnos de establecer nuestra variable gameOver en falso, o no se podrán realizar nuevos movimientos. Agregue esta declaración al final de ese método:</p>

<hr />

<pre><code class="language-C#">gameOver = false;
</code></pre>

<hr />

<p>Determinaremos si el juego ha finalizado llamando a un nuevo método:</p>

<hr />

<pre><code class="language-C#">void CheckGameState()
{
    for (int i = 0; i &lt; wins.GetLength(0); ++i)
    {
        int j = wins[i, 0];
        int k = wins[i, 1];
        int l = wins[i, 2];
        if (cells[j].text == cells[k].text &amp;&amp;
            cells[k].text == cells[l].text &amp;&amp;
            !string.IsNullOrEmpty(cells[j].text))
        {
            gameOver = true;
            Debug.Log(cells[j].text + &quot; GANAS!&quot;);
            Invoke(&quot;NewGame&quot;, 3f);
            break;
        }
    }
}
</code></pre>

<hr />

<p>En este método, recorremos la matriz de líneas donde podría ocurrir una victoria. Dentro del bucle tenemos una &ldquo;declaración if&rdquo; compuesta que requiere que tres cosas sean verdaderas (esto sucede al usar &ldquo;&amp;&amp;&rdquo; que significa &ldquo;y&rdquo;:</p>

<ul>
<li>El valor de la primera celda marcada debe coincidir con el valor de la segunda celda marcada.</li>
<li>El valor de la segunda celda marcada debe coincidir con el valor de la tercera celda marcada.</li>
<li>El valor de la primera celda marcada no debe estar vacío.</li>
</ul>

<p>Si esas tres condiciones se cumplen a la vez, establecemos gameOver en &ldquo;verdadero&rdquo;, imprimimos un mensaje que indica quién ganó, configuramos nuestro método NewGame para que se active en 3 segundos y luego llamamos &ldquo;break&rdquo;, que sale del bucle. No necesitamos seguir buscando victorias una vez que se ha encontrado uno.</p>

<p>A continuación, tenemos que modificar el método SelectCell. No queremos permitir movimientos cuando la variable gameOver es verdadera o cuando la celda ya está tomada. Podemos hacer una comprobación compuesta con O utilizando dos líneas verticales: &ldquo;||&rdquo;. También llamamos a nuestro CheckGameState después de aplicar un movimiento.</p>

<hr />

<pre><code class="language-C#">void CheckGameState()
{
    for (int i = 0; i &lt; wins.GetLength(0); ++i)
    {
        int j = wins[i, 0];
        int k = wins[i, 1];
        int l = wins[i, 2];
        if (cells[j].text == cells[k].text &amp;&amp;
            cells[k].text == cells[l].text &amp;&amp;
            !string.IsNullOrEmpty(cells[j].text))
        {
            gameOver = true;
            Debug.Log(cells[j].text + &quot; GANAS!&quot;);
            Invoke(&quot;NewGame&quot;, 3f);
            break;
        }
    }
}
</code></pre>

<hr />

<p>Guarde su script y regrese a Unity. Juega el juego ahora y activa una condición de victoria. Debería ver un mensaje de felicitación en la consola y luego no podrá realizar nuevos movimientos hasta que el tablero se restablezca.</p>

<p><center><img src="/img/codebackdoor/learncsharpunity/06.gif" alt="005" /></center></p>

<h1 id="resumen">Resumen</h1>

<p>En esta lección, creamos una versión humana jugable de Tic Tac Toe. Pudimos mantener nuestro guion corto y dulce mediante el uso de bucles para iterar sobre las celdas de nuestro tablero de juego. Aprendimos cómo controlar dónde comienzan y terminan los ciclos, qué condiciones requieren y cómo iteran. La sentencia break se introdujo como una forma de salir de los bucles antes de tiempo. También presentamos algunas variaciones a los elementos anteriores, como las declaraciones compuestas con &ldquo;Y&rdquo; y &ldquo;O&rdquo; y las matrices multidimensionales utilizadas.</p>

<p><center><a href="http://bit.ly/2MtKLR8" class="button"><i class="fa fa-caret-right" aria-hidden="true"></i> Siguiente - Genéricos</a></p>

<p><center><img src="/img/ref.png" alt="001" /></center></p>


		
	</section>
    </div>

    <footer class="site-footer">
	<p class="text">&copy; 2022 - Moon Antonio</p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'G-V17LGH4N3N', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
