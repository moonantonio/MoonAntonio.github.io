<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>Aprende C# con Unity - Clases&middot; Antonio Moon´s</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Moon Antonio">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Antonio,Dev,Game">
	<meta name="generator" content="Hugo 0.50" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://moonantonio.github.io/css/main.css">
	<link id="dark-mode-theme" rel="stylesheet" href="/css/dark.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://moonantonio.github.io/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="site-header">
	<div class="branding">
		<a href="https://moonantonio.github.io/">
		<img class="avatar" src="https://moonantonio.github.io/img/avatar.png" alt="avatar"/>
		</a>
		<h1 class="site-title">
			<i class="fa fa-angle-right"></i>
			<a href="https://moonantonio.github.io/">Antonio Moon´s</a>
			<span class="logo-cursor "></span>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			<li><a href="/about/">  </a></li>

			<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/devblog/" title="devBlog">
  		</i>&nbsp; devBlog</a> <i class="fa fa-gamepad" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/backdoor" title="backDoor">
  		</i>&nbsp; backDoor</a> <i class="fa fa-black-tie" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://github.com/MoonAntonio/rec.repos" title="src">
  		</i>&nbsp; src</a> <i class="fa fa-code" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/portfolio/" title="moon">
  		</i>&nbsp; moon</a> <i class="fa fa-terminal" aria-hidden="true"></i>
  </a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="&#43;">
		</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
	</a>
</li>





<li>
	<a href="mailto:antoniomt.moon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>











<li>
	<a href="https://github.com/MoonAntonio" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























<li>
	<a href="https://gitlab.com/MoonAntonio" title="Gitlab">
		<i class="fa fa-fw fa-gitlab"></i>
	</a>
</li>

<li>
	<a href="https://trello.com/antoniomoon" title="Trello">
		<i class="fa fa-fw fa-trello"></i>
	</a>
</li>



			<a id="dark-mode-toggle" class="fa fa-moon-o" title="darkmode"></a>
		</ul>
	</nav>
</header>

    <div class="content">
    <script src="https://moonantonio.github.io/js/darkmode.js"></script>
	<article class="feature-image">
		<header style="background-image: url('https://moonantonio.github.io/img/b/b002.jpg')">
			<h1 class="title">Aprende C# con Unity - Clases</h1>
		</header>

	<section class="post-content">
		

<p>Ya sea que lo recuerdes o no, has estado creando clases todo el tiempo en las lecciones anteriores. He comentado brevemente varias características de clases como herencia y constructores, pero hay mucho más por cubrir. En esta lección, nos enfocaremos en esos temas con mayor profundidad e introduciremos algunos temas más avanzados como polimorfismo, constructores estáticos, clases abstractas y clases estáticas.</p>

<p><center><a href="https://github.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-github-alt"></i>GitHub Repo</a><a href="https://gitlab.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-gitlab"></i>GitLab Repo</a></center></p>

<h1 id="herencia">Herencia</h1>

<p>La herencia es el concepto de que una clase toma todas las funcionalidades de una clase &ldquo;padre&rdquo; o &ldquo;base&rdquo; al mismo tiempo que brinda la oportunidad de ampliar o modificar la lógica previamente disponible. El código de plantilla proporcionado por Unity para todos sus scripts hará que su script herede de &ldquo;MonoBehaviour&rdquo; de forma predeterminada.</p>

<p>Puedes decir qué la clase hereda de tu script al observar los dos puntos en la declaración de clase:</p>

<hr />

<pre><code class="language-C#">public class HerenciaMono : MonoBehaviour
{
  // Yo heredo de MonoBehaviour
}
</code></pre>

<hr />

<p>No tiene que heredar de MonoBehaviour. Puede especificar cualquier otra clase en su lugar como &ldquo;Estadisticas&rdquo; (tenga en cuenta que tendría que haber creado una clase llamada Estadisticas para que compile):</p>

<hr />

<pre><code class="language-C#">public class HerenciaEsta : Estadisticas
{
  // Yo heredo de Estadisticas
}
</code></pre>

<hr />

<p>Si no especifica una clase para heredar, todavía hereda de algo: System.Object:</p>

<hr />

<pre><code class="language-C#">public class ClaseNormal
{
  // Yo heredo de System.Object aunque no lo menciono
}
</code></pre>

<hr />

<p>En C#, una clase solo puede tener una clase base. Si desea algo así como herencia múltiple, considere usar interfaces o arquitecturas basadas en componentes en su lugar.</p>

<h1 id="polimorfismo">Polimorfismo</h1>

<p>MonoBehaviour hereda de Behavior, que a su vez hereda de Component. El componente hereda de UnityEngine.Object que finalmente hereda de System.Object. Puedo decir que un MonoBehaviour es cualquiera de esas clases base (pero no siempre puedo decir lo contrario). Considere el siguiente ejemplo:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
#endregion

namespace MoonAntonio
{
    public class Polimorfismo : MonoBehaviour 
    {
        void Start()
        {
            List&lt;System.Object&gt; myList = new List&lt;System.Object&gt;();
            myList.Add(&quot;Hola Mundo!&quot;);
            myList.Add(42);
            myList.Add(Camera.main);
            for (int i = 0; i &lt; myList.Count; ++i)
                Debug.Log(i + &quot;: &quot; + myList[i].ToString());
        }
    }
}
</code></pre>

<hr />

<p>En este fragmento, declaro una lista genérica de objetos. Una lista genérica está restringida a contener un solo tipo de datos. Sin embargo, agrego tres cosas muy diferentes: una cadena de texto, un valor entero y un componente de cámara, todo sin problema. Cada uno de los tipos &ldquo;concretos&rdquo; aún comparte una &ldquo;base&rdquo; de &ldquo;Objeto&rdquo; y por lo tanto son adiciones válidas a la lista.</p>

<p>Debido al polimorfismo, puedo tratar estos tres elementos muy diferentes exactamente de la misma manera. Para demostrarlo, recorro todos los elementos de la lista y llamo a un método, todos comparten &ldquo;ToString&rdquo; e imprimen el resultado en la consola. El resultado es el siguiente:</p>

<p>0: Hola Mundo!
1: 42
2: Cámara principal (UnityEngine.Camera)</p>

<p>Cada elemento sabía cómo convertirse en una cadena a pesar de que todos pueden manejar el proceso de manera diferente. Por ejemplo, el componente de la cámara imprimió un mensaje informativo que incluía el nombre del GameObject al que estaba adjuntado. El código &ldquo;cliente&rdquo; (nuestro script de demostración que imprimió los mensajes en la consola) no necesita saber que los objetos son diferentes o cómo responderán a la llamada al método. Solo necesita saber que tienen el método.</p>

<p>Siempre es seguro tratar un objeto como una versión de clase base de sí mismo. Sin embargo, no siempre es seguro tratar una referencia de una clase base como una clase que hereda de ella. Considere la siguiente línea de código:</p>

<hr />

<pre><code class="language-C#">Camera c = myList[2];
</code></pre>

<hr />

<p>Aunque sé que el objeto en el índice 2 de myList es una cámara, no puedo agregar esta línea al final del método. Si lo intenta, obtendrá un error, &ldquo;error CS0266: no se puede convertir implícitamente el tipo objeto &lsquo;en UnityEngine.Camera&rsquo;. Existe una conversión explícita (¿falta algo?) &ldquo;</p>

<p>El motivo por el que se produce este error es porque, aunque todos los componentes de la cámara son Objetos, no todos los objetos son cámaras. Esto es evidente incluso en la demostración, porque los otros dos &ldquo;objetos&rdquo; en la lista no son cámaras.</p>

<p>Para trabajar con el objeto en su verdadera forma, ahora debe &ldquo;echar&rdquo; el objeto hacia atrás. También puedes verificar primero el &ldquo;tipo&rdquo; de un objeto para asegurarte de que funcionará:</p>

<hr />

<pre><code class="language-C#">// Verifica el tipo de una referencia de objeto con la palabra clave &quot;es&quot;
if (myList[2] is Camera)
{
    // Emitir la referencia usando el nombre de la clase entre paréntesis
    Camera c = (Camera)myList[2];
}
</code></pre>

<hr />

<p>Alternativamente, puede usar una palabra clave &ldquo;as&rdquo; para intentar tratar un objeto como un tipo específico:</p>

<hr />

<pre><code class="language-C#">Camera c = myList[1] as Camera;
Debug.Log(&quot;success: &quot; + (c != null));
</code></pre>

<hr />

<p>Tenga en cuenta que en el ejemplo anterior, hice referencia al objeto en el índice 1 (un entero) que no se puede convertir a una cámara. Al usar la palabra clave &ldquo;as&rdquo;, a nuestra variable local se le asignará una referencia &ldquo;nula&rdquo; en el caso en que el lanzamiento falle.</p>

<h1 id="cómo-modificar-la-funcionalidad-de-la-clase-base">Cómo modificar la funcionalidad de la clase base</h1>

<p>Vimos que la implementación ToString de la cámara que es diferente de la implementación ToString de un entero. Supongamos que queremos que nuestro script crea una implementación diferente. Ponga el cursor fuera de sus otros métodos y comience a escribir &ldquo;override&rdquo; las características de autocompletar de su editor de scripts con la esperanza de comenzar y sugerir métodos que puede modificar. Visual studio me muestra: Equals, GetHashCode y ToString como opciones válidas para sobrescribir. Al seleccionar ToString, mi editor creó el siguiente fragmento:</p>

<hr />

<pre><code class="language-C#">public override string ToString ()
{
  return string.Format (&quot;[Demo]&quot;);
}
</code></pre>

<hr />

<p>La firma de este método debe resultarle familiar, con la excepción de la palabra clave &ldquo;override&rdquo;, que es lo que nos informa que podemos reemplazar, modificar o extender la funcionalidad de la clase base.</p>

<p>Con la implementación tal como está, llamar a ToString en instancias de nuestra clase informará a los usuarios que están haciendo referencia a una instancia de la clase Demo. Si tuviéramos información adicional que sería conveniente saber, podríamos agregarla a la cadena. Por ejemplo, imagine que teníamos dos campos llamados &lsquo;x&rsquo; e &lsquo;y&rsquo; que contienen información de coordenadas. Entonces podría usar la siguiente línea que nos dirá que tenemos una instancia de demostración así como también los valores que tiene actualmente:</p>

<hr />

<pre><code class="language-C#">return string.Format (&quot;[{0} x:{1} y:{2}]&quot;, base.ToString(), x, y);
</code></pre>

<hr />

<h1 id="cómo-preparar-una-clase-para-la-herencia">Cómo preparar una clase para la herencia</h1>

<p>Imagina que quieres tener un montón de objetos de juego que sean &ldquo;seleccionables&rdquo;, pero cuando los seleccionas pasan cosas diferentes. Por ejemplo, seleccionar una silla puede hacer que el material de la silla destelle, lo que indica que lo tocó. Seleccionar un personaje puede causar una animación especial y un efecto de sonido para jugar. La mayoría de la lógica de selección en sí misma será la misma, pero los detalles de lo que sucede después de haber sido seleccionado son diferentes. En este caso, querrá volver a utilizar todo el código posible y luego extenderlo a la variación.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using System.Collections;
#endregion

namespace MoonAntonio
{
    public abstract class Selectable : MonoBehaviour
    {
        public bool isSelected { get; protected set; }
        public virtual void SetSelected(bool value)
        {
            if (isSelected == value)
                return;
            isSelected = value;
            if (isSelected)
                Select();
            else
                Deselect();
        }
        protected abstract void Select();
        protected abstract void Deselect();
    }
}
</code></pre>

<hr />

<p>Esta muestra presenta varias palabras clave nuevas. En la definición de clase, incluí la palabra clave &ldquo;abstract&rdquo;. Una clase base abstracta es una clase que no puede ser instanciada; si lo intenta, obtendrá un error, &ldquo;error CS0144: No se puede crear una instancia de la clase abstracta o interfaz &lsquo;Selectable&rsquo;&rdquo;</p>

<p>Lo mismo cuando trates de adjuntar un componente abstracto a un objeto en Unity. Verá un cuadro de diálogo de error si lo intenta, &ldquo;No se puede agregar el comportamiento del script Selectable. ¡La clase de guion no puede ser abstracta!</p>

<p>La razón por la que desea marcar un resumen de clase es porque cuando usa esta palabra clave, puede declarar métodos sin implementarlos. Puede dejar detalles específicos de implementación hasta subclases.</p>

<p>Con respecto a la visibilidad, ya he hablado de &ldquo;public&rdquo; y &ldquo;private&rdquo;, pero la propiedad de esta clase usa una nueva palabra clave: un &ldquo;protected&rdquo;. Esta palabra clave es similar a &ldquo;private&rdquo;, excepto que las subclases también tienen acceso permitido. Entonces, básicamente, la propiedad &ldquo;isSelected&rdquo; puede ser leída por otras clases, pero solo puede ser escrita por ella misma o por subclases de ella misma.</p>

<p>Tenemos un método público, llamado &ldquo;SetSelected&rdquo; que acepta un parámetro bool que indica si el objeto será o no seleccionado. Marqué este método como &ldquo;virtual&rdquo;, lo que indica que las subclases pueden &ldquo;override&rdquo; si desean modificar, reemplazar o ampliar la funcionalidad, pero no es necesario. Proporcioné una implementación predeterminada que funciona. El método en sí mismo verifica si estamos tratando de establecer el objeto en un estado de selección en el que ya se encuentra, y si es así, regresa. Luego marca la propiedad isSelected y llama a un método que refleja su nuevo estado de selección.</p>

<p>Finalmente tengo dos métodos &ldquo;protegidos&rdquo;, &ldquo;Select&rdquo; y &ldquo;Deselect&rdquo;. Protegido implica el mismo significado aquí, otras clases no pueden ver o invocar estos métodos, a menos que sean una subclase de &ldquo;Selectable&rdquo;. También marqué los dos métodos como &ldquo;abstract&rdquo; que, a diferencia del uso de &ldquo;virtual&rdquo;, significa que la subclase debe &ldquo;override&rdquo; el método (a menos que también sean clases abstractas).</p>

<p>Tenga en cuenta que solo puede marcar un método como abstracto si la clase también es abstracta o si obtiene un error, &ldquo;error CS0513: Selectable.Select() &lsquo;es abstracto pero se declara en la clase no abstracta Selectable&rsquo;&rdquo;</p>

<p>Si crea una subclase no abstracta y no implementa los métodos abstractos, obtendrá otro error, &ldquo;error CS0534: SelectableDecoration &lsquo;no implementa el miembro abstracto heredado Selectable.Select()&rsquo;&rdquo;</p>

<h1 id="constructores-y-destructores">Constructores y Destructores</h1>

<p>Los constructores le permiten controlar lo que sucede cuando se crea una instancia de un objeto o cómo se crea una instancia. Los destruidores le permiten controlar lo que sucede cuando se destruye un objeto y proporcionan una forma de limpiar los recursos, etc.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class Point
    {
        public int x;
        public int y;

        public Point()
        {
            Debug.Log(&quot;¡Estoy vivo! ... pero estoy a cero.&quot;);
        }

        public Point(int x, int y)
        {
            this.x = x;
            this.y = y;
            Debug.Log(&quot;Whoooa, debo ser valioso!&quot;);
        }

        ~Point()
        {
            Debug.Log(&quot;Me estoy derritiendo, FUNDICIÓN !!!&quot;);
        }
    }

    public class Constructores : MonoBehaviour 
    {
        public void Start()
        {
            Point p1 = new Point();
            Point p2 = new Point(2, 5);
        }
    }
}
</code></pre>

<hr />

<p>Esta muestra definió una clase llamada &ldquo;Point&rdquo; que muestra dos constructores diferentes: un constructor &ldquo;predeterminado&rdquo; (uno sin parámetros) y un constructor con parámetros. Se puede decir que un método es un constructor porque no tiene un tipo de retorno y porque el identificador tiene el mismo nombre que el nombre de la clase.</p>

<p>La clase Constructores crea dos instancias de la clase Point, una para cada tipo de constructor. Tenga en cuenta que debe usar la palabra clave &ldquo;new&rdquo; junto con el constructor o obtendrá un error, &ldquo;error CS0119: expresión denota un &lsquo;tipo&rsquo;, donde se esperaba una variable, valor o grupo de métodos&rdquo;</p>

<p>También tenga en cuenta que no debe usar constructores con scripts basados ​​en MonoBehaviour. Si lo intenta, verá una advertencia en la consola, &ldquo;Está tratando de crear un comportamiento mono con la palabra clave &lsquo;new&rsquo;. Esto no esta permitido. MonoBehaviours solo se puede agregar usando AddComponent(). Alternativamente, su script puede heredar de ScriptableObject o no tener ninguna clase base&rdquo;. Unity requiere que cree objetos y que una los componentes de manera especial para que pueda configurar y rastrear todo correctamente.</p>

<p>Nuestra clase Point también define un &ldquo;Destructor&rdquo; que puedes identificar con la tilde que procede con un identificador que coincide con el nombre de la clase. A diferencia de un constructor, no invocas directamente un destructor. Se llamará automáticamente cuando un objeto sale &ldquo;fuera del alcance&rdquo; o se destruye. En este ejemplo, las instancias de dos puntos son locales al método &ldquo;Start&rdquo;, por lo que tan pronto como el método finalice ya estarán fuera del alcance.</p>

<p>Si adjunta este script a un GameObject y ejecuta su escena, verá el siguiente resultado en la ventana de la consola:</p>

<p>¡Estoy vivo! &hellip; pero estoy a cero.
Whoooa, debo ser valioso!
Me estoy derritiendo, FUNDICIÓN !!!
Me estoy derritiendo, FUNDICIÓN !!!</p>

<h1 id="constructores-estáticos">Constructores estáticos</h1>

<p>De la misma manera que puede especificar la lógica para el inicio de una instancia de una clase, también puede especificar la lógica para el inicio de la clase. Un constructor estático no se invoca directamente, sino que se llamará inmediatamente (y solo una vez) tan pronto como cualquier clase haga referencia a la clase. Un constructor estático parece un constructor normal, pero va precedido de la palabra clave &ldquo;static&rdquo;.</p>

<hr />

<pre><code class="language-C#">static Point ()
{
  Debug.Log(&quot;Hola Mundo!&quot;);
}
</code></pre>

<hr />

<p>Si agregó esto a la clase Point en la muestra anterior, verá &ldquo;Hola Mundo!&rdquo; Impreso en la consola antes de que se haya instanciado el primer punto.</p>

<p>Si su clase hace uso de variables estáticas, el constructor estático es un buen lugar para inicializarlas.</p>

<h1 id="clases-estáticas">Clases estáticas</h1>

<p>Una clase que está marcada como estática no puede ser instanciada. Todas las variables y métodos que contiene también se deben marcar como estáticos.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using System.Collections;
#endregion

namespace MoonAntonio
{
    public static class Global
    {
      public static int count;

      public static void DoStuff ()
      {
        count++;
        Debug.Log(&quot;Tengo &quot; + count);
      }
    }
}
</code></pre>

<hr />

<p>Si intenta crear una instancia de una clase estática, obtendrá un error, &ldquo;error CS0723: prueba: no ​​puede declarar variables de tipos estáticos&rdquo;</p>

<p>Si intentas subclasificar una clase estática, también obtendrás un error, &ldquo;error CS0709: Test : no ​​puede derivar de la clase estática Global&rdquo;</p>

<p>Trabaja con una clase estática haciendo referencia al nombre de la clase y usa la notación de puntos, como Global.DoStuff();</p>

<p>Las clases estáticas pueden ser formas convenientes de almacenar información a la que cualquier cosa puede acceder desde cualquier punto, porque no necesita hacer un seguimiento u obtener una instancia de la clase. Tenga en cuenta que los campos estáticos vivirán tanto como lo haga la clase, que es la duración del programa.</p>

<p><center><img src="/img/codebackdoor/learncsharpunity/09.gif" alt="008" /></center></p>

<h1 id="resumen">Resumen</h1>

<p>En esta lección, cubrimos una gran cantidad de características de las clases que incluyen constructores normales y estáticos, destructores, herencia y polimorfismo. Introduje nuevas palabras clave como abstract, virtual, override y protected. También mostré cómo una clase en sí misma puede ser abstracta o estática. Aunque muchas de estas características son fáciles de mostrar, se pueden considerar material avanzado. La arquitectura que aprovecha estas características puede ser difícil de entender por completo.</p>

<p><center><a href="http://bit.ly/2Mzk11u" class="button"><i class="fa fa-caret-right" aria-hidden="true"></i> Siguiente - Guardando datos</a></p>

<p><center><img src="/img/ref.png" alt="001" /></center></p>


		
	</section>
    </div>

    <footer class="site-footer">
	<p class="text">&copy; 2022 - Moon Antonio</p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-89564434-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
