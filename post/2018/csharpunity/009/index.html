<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>Aprende C# con Unity - Guardando datos&middot; Antonio Moon´s</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Moon Antonio">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Antonio,Dev,Game">
	<meta name="generator" content="Hugo 0.50" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://moonantonio.github.io/css/main.css">
	<link id="dark-mode-theme" rel="stylesheet" href="/css/dark.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://moonantonio.github.io/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="site-header">
	<div class="branding">
		<a href="https://moonantonio.github.io/">
		<img class="avatar" src="https://moonantonio.github.io/img/avatar.png" alt="avatar"/>
		</a>
		<h1 class="site-title">
			<i class="fa fa-angle-right"></i>
			<a href="https://moonantonio.github.io/">Antonio Moon´s</a>
			<span class="logo-cursor "></span>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			<li><a href="/about/">  </a></li>

			<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/devblog/" title="devBlog">
  		</i>&nbsp; devBlog</a> <i class="fa fa-gamepad" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/backdoor" title="backDoor">
  		</i>&nbsp; backDoor</a> <i class="fa fa-black-tie" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://github.com/MoonAntonio/rec.repos" title="src">
  		</i>&nbsp; src</a> <i class="fa fa-code" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/portfolio/" title="moon">
  		</i>&nbsp; moon</a> <i class="fa fa-terminal" aria-hidden="true"></i>
  </a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="&#43;">
		</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
	</a>
</li>





<li>
	<a href="mailto:antoniomt.moon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>











<li>
	<a href="https://github.com/MoonAntonio" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























<li>
	<a href="https://gitlab.com/MoonAntonio" title="Gitlab">
		<i class="fa fa-fw fa-gitlab"></i>
	</a>
</li>

<li>
	<a href="https://trello.com/antoniomoon" title="Trello">
		<i class="fa fa-fw fa-trello"></i>
	</a>
</li>



			<a id="dark-mode-toggle" class="fa fa-moon-o" title="darkmode"></a>
		</ul>
	</nav>
</header>

    <div class="content">
    <script src="https://moonantonio.github.io/js/darkmode.js"></script>
	<article class="feature-image">
		<header style="background-image: url('https://moonantonio.github.io/img/b/b002.jpg')">
			<h1 class="title">Aprende C# con Unity - Guardando datos</h1>
		</header>

	<section class="post-content">
		

<p>Supongamos que estás haciendo un juego &ldquo;completo&rdquo;. Quieres una pantalla de título y todo. Su usuario puede seleccionar el número de jugadores o una configuración de dificultad, etc., y luego &hellip; ¿cómo pasa la información a la siguiente escena? O, lo que es más importante (y algo truculento) ¿cómo se puede guardar una sesión de juego y volver a cargarla más tarde? mostraré algunas de las opciones que me gustan.</p>

<p><center><a href="https://github.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-github-alt"></i>GitHub Repo</a><a href="https://gitlab.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-gitlab"></i>GitLab Repo</a></center></p>

<h1 id="persistencia-estática">Persistencia estática</h1>

<p>Para persistir los datos de una escena a otra puede ser tan simple como guardar datos en una variable estática. Para demostrarlo, necesitaremos un poco de configuración. Crea dos escenas, una llamada &ldquo;Título&rdquo; y otra llamada &ldquo;Juego&rdquo;. En la barra de menú, seleccione &ldquo;File-&gt; Build Settings&rdquo; y en el cuadro de diálogo deberá usar el botón &ldquo;Agregar actual&rdquo; o arrastrar y soltar ambas escenas desde el panel Proyecto a la lista &ldquo;Escenas en compilación&rdquo;.</p>

<p>La siguiente clase de Data Manager es una clase estática con una variable estática, por lo que no necesita ser agregada a su escena, simplemente &ldquo;funcionará&rdquo; automáticamente. Utilizo algo llamado &ldquo;enumeración&rdquo; de la que no he hablado antes. Por ahora, puede pensar en una enumeración como un entero (porque puede ser emitida desde o hacia un número entero, aunque en realidad es su propio &ldquo;tipo&rdquo;) donde cada entrada se nombra para hacer que su código sea más legible. &ldquo;Fácil&rdquo; es como el valor entero de &lsquo;0&rsquo; y cuenta desde allí.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public enum Difficulties
    {
        Easy,
        Medium,
        Hard,
        Count
    }

    public static class DataManager 
    {
        public static Difficulties difficulty;
    }
}
</code></pre>

<hr />

<p>Agregue el siguiente script &ldquo;TitleController&rdquo; como un componente a la cámara en la escena &ldquo;Título&rdquo;. Este script es muy simple: utilicé la GUI heredada para reducir aún más el tiempo de configuración. Todo lo que hace este script es mostrar botones para cada opción de dificultad, y uno para comenzar a jugar el juego. Cada vez que selecciona uno de los botones, una configuración de dificultad se establece en una variable estática en la clase DataManager.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using UnityEngine.SceneManagement;
#endregion

namespace MoonAntonio
{
    public class TitleController : MonoBehaviour 
    {
        void OnGUI()
        {
            int yPos = 10;
            GUI.Label(new Rect(10, yPos, 200, 30), &quot;Elegir dificultad&quot;);
            for (int i = 0; i &lt; (int)Difficulties.Count; ++i)
            {
                yPos += 40;
                Difficulties type = (Difficulties)i;
                if (DataManager.difficulty == type)
                    GUI.Label(new Rect(10, yPos, 200, 30), type.ToString());
                else if (GUI.Button(new Rect(10, yPos, 100, 30), type.ToString()))
                    DataManager.difficulty = type;
            }
            yPos += 40;
            if (GUI.Button(new Rect(10, yPos, 100, 30), &quot;Play&quot;))
                SceneManager.LoadScene(&quot;Juego&quot;);
        }
    }
}
</code></pre>

<hr />

<p>Agregue el siguiente script &ldquo;GameController&rdquo; como un componente, a la cámara en la escena &ldquo;Juego&rdquo;. Este script también es muy simple. Esta vez todo lo que hago es mostrar qué dificultad se ha seleccionado en la escena de Título y proporcionar una opción para Salir de nuevo a esa escena.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using UnityEngine.SceneManagement;
#endregion

namespace MoonAntonio
{
    public class GameController : MonoBehaviour 
    {
        void OnGUI()
        {
            GUI.Label(new Rect(10, 10, 200, 30), DataManager.difficulty.ToString());
            if (GUI.Button(new Rect(10, 50, 100, 30), &quot;Salir&quot;))
                SceneManager.LoadScene(&quot;Titulo&quot;);
        }
    }
}
</code></pre>

<hr />

<p>Con la escena de título abierta, presione Reproducir y observe que la selección que hace en la primera pantalla se guarda y aún está disponible en la siguiente escena. Esto funciona porque las variables estáticas nunca saldrán del alcance mientras el programa se esté ejecutando.</p>

<h1 id="patrón-singleton">Patrón Singleton</h1>

<p>Aunque una clase estática funcionó bien para la muestra anterior, no ofrece tantas opciones arquitectónicas como lo haría un objeto (a saber, herencia y polimorfismo). Un singleton es una variación ligeramente diferente, donde por diseño solo se desea que exista una sola instancia de una clase, pero se puede tener más control sobre la creación y la vida útil del objeto, se pueden usar subclases, etc.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class DataManagerSingleton 
    {
        public static readonly DataManagerSingleton instance = new DataManagerSingleton();
        private DataManagerSingleton() { }
        public Difficulties difficulty;
    }
}
</code></pre>

<hr />

<p>Aquí he modificado la clase DataManagerSingleton para que ya no sea estática. Creo una instancia estática de solo lectura de la clase (para que ninguna otra clase pueda destruirla o reasignarla) y hacer que el constructor sea privado (para que ninguna otra clase pueda instanciar otro objeto). Esto obliga al patrón singleton a ser utilizado como yo pretendía.</p>

<p>Ahora, la lectura y escritura de la configuración de dificultad debe enrrutarse a través de la instancia singleton. La siguiente línea muestra un ejemplo de cómo escribir el valor:</p>

<hr />

<pre><code class="language-C#">DataManagerSingleton.instance.difficulty = type;
</code></pre>

<hr />

<h1 id="unity-singleton">Unity &ldquo;Singleton&rdquo;</h1>

<p>A veces puede ser conveniente utilizar una clase basada en MonoBehaviour para su persistencia (en caso de que desee aprovechar Coroutines, etc.) En ese caso, puede hacer que GameObjects &ldquo;sobrevivan&rdquo; a un cambio de escena utilizando el método &ldquo;DontDestroyOnLoad&rdquo;. Tenga en cuenta que esta es también una forma útil de hacer que la música se reproduzca entre los cambios de escena.</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class DataManagerUnitySingleton : MonoBehaviour 
    {
        public static DataManagerUnitySingleton instance
        {
            get
            {
                if (_instance == null)
                {
                    GameObject obj = new GameObject(&quot;Data Manager Unity Singleton&quot;);
                    _instance = obj.AddComponent&lt;DataManagerUnitySingleton&gt;();
                    DontDestroyOnLoad(obj);
                }
                return _instance;
            }
        }
        static DataManagerUnitySingleton _instance;
        public Difficulties difficulty;
    }
}
</code></pre>

<hr />

<p>Esta versión del DataManagerUnitySingleton hereda de MonoBehaviour. El &ldquo;Singleton&rdquo; es creado por algo llamado &ldquo;Lazy Loading&rdquo; lo que significa que tan pronto como un script llame a la propiedad &ldquo;instance&rdquo;, la clase verá su &ldquo;getter&rdquo; y determinará si ha creado uno. De lo contrario, creará un nuevo GameObject, asignará el componente correcto y se asegurará de que GameObject esté marcado correctamente para que no se destruya al cambiar de escena.</p>

<p>Esta versión no es tan &ldquo;segura&rdquo; como la versión anterior, porque hay formas en que otros scripts pueden hacer que se destruya el GameObject de su script, y aunque su script &ldquo;sobreviva&rdquo; debido a la referencia estática, la comparación con null aún devuelve verdadero porque Unity anula el operador (para tener en cuenta el GameObject), por lo tanto, se crearía otro GameObject/Singleton.</p>

<p>Además, nada impide que otro script agregue copias adicionales de este componente a otros GameObjects, aunque como no proporcioné ningún setter, solo se reconocerá un componente a la vez como instancia principal.</p>

<p>Si quereis ver una muestra de un Singleton para Unity comun, <a href="http://bit.ly/2NglfuU">id aqui</a>.</p>

<h1 id="player-prefs">Player Prefs</h1>

<p>Todos los ejemplos hasta ahora son buenas maneras de tomar datos de una escena a otra, sin embargo, ninguno de ellos puede conservar datos en varias sesiones de juego. Para realizar esta tarea, debe guardar los datos en &ldquo;disco&rdquo; de una forma u otra. Unity proporciona una solución conveniente sin necesidad de comprender cómo crear, leer y escribir en archivos. Esta solución se llama PlayerPrefs - <a href="http://bit.ly/2PB3Mz1">vea la documentación aquí</a></p>

<p>Puedes pensar en PlayerPrefs como un diccionario que solo sabe cómo trabajar con una &ldquo;cadena&rdquo; para la clave y un &ldquo;int&rdquo;, &ldquo;float&rdquo; o &ldquo;string&rdquo; para el valor. A diferencia de un diccionario genérico, puede mezclar y combinar cualquier combinación de esos valores.</p>

<p>Aquí hay algunos casos de uso:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    public class PlayerPrefsExample : MonoBehaviour 
    {
        private void Start()
        {
            // Almacenar un valor entero
            PlayerPrefs.SetInt(&quot;Difficulty&quot;, 0);
            // Recupere un valor entero (si existe, o use un valor predeterminado de '0' de lo contrario)
            DataManagerUnitySingleton.instance.difficulty = (Difficulties)PlayerPrefs.GetInt(&quot;Difficulty&quot;, 0);
        }
    }
}
</code></pre>

<hr />

<h1 id="serializacion">Serializacion</h1>

<p>Mencioné la serialización desde el principio: Unity utiliza la serialización para almacenar los valores de sus componentes mientras está en el editor. Desafortunadamente, muchas de las opciones convenientes que te gustaría utilizar, como un Serializador Binario o XML, requerirían que puedas usar un Constructor, no una opción con MonoBehaviour. Además, la jerarquía de objetos, las referencias a objetos y el deseo de persistir en los valores de los componentes nativos de Unity complican enormemente este proceso.</p>

<p>El método que prefiero es la serialización manual en cadenas JSON. Aunque requiere un poco más de configuración que algunas de las otras rutas, creo que tengo muchas más opciones y mantengo un control total sobre el proceso. Tampoco tengo que preocuparme por &ldquo;versionar&rdquo; mis datos. Puedo eliminar datos, agregar datos, cambiar tipos de datos, etc. y no hará que el serializador se bloquee, porque puedo controlar el proceso de qué y cómo persisto los datos. Por ejemplo, puedo verificar la presencia de claves y tratar de enviar tipos de datos donde sea necesario. Además, como estoy serializando una cadena JSON, puedo fácilmente persistir el resultado en PlayerPrefs, enviarlo a un servidor o escribirlo en un archivo local como lo desee.</p>

<p>Decidí no volver a inventar la rueda esta vez, y usé un script público para la serialización JSON. Tome una copia <a href="http://bit.ly/2BFLpFW">aquí</a>, y agréguelo a su proyecto.</p>

<p>Crea una nueva escena llamada &ldquo;Demo&rdquo;. Crea un Cubo (desde la barra de menú elige &ldquo;GameObject-&gt; Objet 3D-&gt; Cube&rdquo;) y luego crea y adjunta el siguiente script &ldquo;Monster&rdquo; (¿porque no es más divertido trabajar con monstruos?)</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
#endregion

namespace MoonAntonio
{
    public class Monster : MonoBehaviour 
    {
        public int HP;

        public virtual Dictionary&lt;string, object&gt; Save()
        {
            Dictionary&lt;string, object&gt; data = new Dictionary&lt;string, object&gt;();
            data.Add(&quot;HP&quot;, HP);
            data.Add(&quot;X&quot;, transform.localPosition.x);
            data.Add(&quot;Y&quot;, transform.localPosition.y);
            data.Add(&quot;Z&quot;, transform.localPosition.z);
            data.Add(&quot;Prefab&quot;, gameObject.name);
            return data;
        }

        public virtual void Load(Dictionary&lt;string, object&gt; data)
        {
            HP = Convert.ToInt32(data[&quot;HP&quot;]);
            float x = Convert.ToSingle(data[&quot;X&quot;]);
            float y = Convert.ToSingle(data[&quot;Y&quot;]);
            float z = Convert.ToSingle(data[&quot;Z&quot;]);
            transform.localPosition = new Vector3(x, y, z);
        }
    }
}
</code></pre>

<hr />

<p>Este script tiene un solo campo para &ldquo;HP&rdquo; - puntos de golpe. En realidad, no hace nada, pero quiero mostrar que podremos guardar tanto una variable local como valores del componente de transformación. Los métodos de Guardar y Cargar sirven (con suerte). Envuelven los datos del objeto en un diccionario genérico que el script MiniJSON sabe cómo serializar en una cadena JSON.</p>

<p>Cree y adjunte la siguiente secuencia de comandos a la cámara y luego conecte el cubo como referencia para el campo de monstruos:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
#endregion

namespace MoonAntonio
{
    public class Monster : MonoBehaviour 
    {
        public int HP;

        public virtual Dictionary&lt;string, object&gt; Save()
        {
            Dictionary&lt;string, object&gt; data = new Dictionary&lt;string, object&gt;();
            data.Add(&quot;HP&quot;, HP);
            data.Add(&quot;X&quot;, transform.localPosition.x);
            data.Add(&quot;Y&quot;, transform.localPosition.y);
            data.Add(&quot;Z&quot;, transform.localPosition.z);
            data.Add(&quot;Prefab&quot;, gameObject.name);
            return data;
        }

        public virtual void Load(Dictionary&lt;string, object&gt; data)
        {
            HP = Convert.ToInt32(data[&quot;HP&quot;]);
            float x = Convert.ToSingle(data[&quot;X&quot;]);
            float y = Convert.ToSingle(data[&quot;Y&quot;]);
            float z = Convert.ToSingle(data[&quot;Z&quot;]);
            transform.localPosition = new Vector3(x, y, z);
        }
    }
}
</code></pre>

<hr />

<p>Este script usa la GUI antigua como antes, para mover el monstruo, guardar sus datos o Cargar sus datos. Utilizo el script MiniJSON que descargué para la serialización, y luego guardo el resultado en PlayerPrefs para mayor persistencia.</p>

<p>Ejecuta la escena. Haga clic en Random. En algún momento, haga clic en Guardar y luego click en random algunas veces más. Ahora haz clic en Cargar y ve que el monstruo regresa a la ubicación en la que estaba cuando pulsastes Guardar. Detener la escena y luego ejecutarla de nuevo. ¡El monstruo aún debería estar en el lugar donde lo guardaste!</p>

<p>Aunque técnicamente sabes todo lo que necesitas en este momento, algunos problemas más pueden no ser obvios. Por ejemplo, ¿qué sucede si tiene una lista de objetos que desea guardar? ¿Necesitas crear un nuevo jugador pref para cada uno? ¿Qué pasa si quieres usar el polimorfismo o crear objetos dinámicamente y persistir? Estos son requisitos arquitectónicos muy normales, así que vamos a manejarlos a continuación.</p>

<p>Para nuestro primer paso, necesitaremos modificar el script de Monster para que los métodos de Guardar y Cargar estén marcados como &ldquo;virtuales&rdquo;. De esta forma, no es necesario volver a escribir completamente el código de persistencia en cada subclase; en su lugar, solo tenemos que override el método base y anexar los datos nuevos que proporcione la clase secundaria.</p>

<p>Decidí crear tres subclases de Monster: &ldquo;BlueMonster&rdquo;, &ldquo;RedMonster&rdquo; y &ldquo;GreenMonster&rdquo;. Lo sé, nombres de clase muy imaginativos ¿no? El monstruo azul se ve a continuación:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
#endregion

namespace MoonAntonio
{
    public class BlueMonster : Monster 
    {
        public int water;

        void Awake()
        {
            water = UnityEngine.Random.Range(10, 100);
        }

        public override Dictionary&lt;string, object&gt; Save()
        {
            Dictionary&lt;string, object&gt; data = base.Save();
            data.Add(&quot;Water&quot;, water);
            return data;
        }

        public override void Load(Dictionary&lt;string, object&gt; data)
        {
            base.Load(data);
            water = Convert.ToInt32(data[&quot;Water&quot;]);
        }
    }
}
</code></pre>

<hr />

<p>Los monstruos rojos y verdes tienen implementaciones idénticas, excepto que el nombré a la variable local es &ldquo;fire&rdquo; y &ldquo;earth&rdquo; en vez de water, respectivamente. El objetivo aquí es ilustrar que no se puede usar la misma serialización en los tres porque tienen conjuntos de datos &ldquo;diferentes&rdquo;. Sin embargo, debido a que comparten una clase base común, puedo tratarlos de todos modos y ser capaz de guardarlos y cargarlos sin preocuparse por sus diferencias.</p>

<p>Para ayudar a enfatizar las diferencias entre nuestros monstruos, crea tres prefabricados diferentes en tu proyecto, uno para cada monstruo. Puede hacer una con una esfera y otra con un cubo, pero como mínimo colorearlas todas según su nombre para ayudar a demostrar que hay una diferencia. Asegúrese y asigne el script de subclase específico para cada tipo de monstruo y no la versión de clase base de sí mismo.</p>

<p>Ahora tenemos que modificar la secuencia de comandos Demo para nuestra nueva funcionalidad:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using MiniJSON;
#endregion

namespace MoonAntonio
{
    public class DemoControllerSerializacion : MonoBehaviour 
    {
        [SerializeField] GameObject[] prefabs;
        Dictionary&lt;string, GameObject&gt; mapping = new Dictionary&lt;string, GameObject&gt;();
        List&lt;Monster&gt; monsters = new List&lt;Monster&gt;();

        void Start()
        {
            for (int i = 0; i &lt; prefabs.Length; ++i)
                mapping.Add(prefabs[i].name, prefabs[i]);
            Load();
        }

        void OnGUI()
        {
            if (GUI.Button(new Rect(10, 10, 100, 30), &quot;Agregar&quot;))
                AddRandom();

            if (GUI.Button(new Rect(10, 50, 100, 30), &quot;Guardar&quot;))
                Save();

            if (GUI.Button(new Rect(10, 90, 100, 30), &quot;Cargar&quot;))
                Load();
        }

        void Randomize(Monster monster)
        {
            monster.HP = UnityEngine.Random.Range(10, 100);
            float x = UnityEngine.Random.Range(-10f, 10f);
            float y = UnityEngine.Random.Range(-10f, 10f);
            float z = UnityEngine.Random.Range(-10f, 10f);
            monster.transform.localPosition = new Vector3(x, y, z);
        }

        void AddRandom()
        {
            GameObject prefab = prefabs[UnityEngine.Random.Range(0, prefabs.Length)];
            Monster monster = Add(prefab);
            Randomize(monster);
        }

        Monster Add(GameObject prefab)
        {
            GameObject instance = Instantiate(prefab) as GameObject;
            Monster monster = instance.GetComponent&lt;Monster&gt;();
            monster.name = prefab.name;
            monsters.Add(monster);
            return monster;
        }

        void Save()
        {
            var monsterData = new List&lt;Dictionary&lt;string, object&gt;&gt;(monsters.Count);
            for (int i = 0; i &lt; monsters.Count; ++i)
                monsterData.Add(monsters[i].Save());

            string json = Json.Serialize(monsterData);
            Debug.Log(json);
            PlayerPrefs.SetString(&quot;Monsters&quot;, json);
        }

        void Load()
        {
            Clear();
            string json = PlayerPrefs.GetString(&quot;Monsters&quot;, string.Empty);
            if (!string.IsNullOrEmpty(json))
            {
                var monsterData = Json.Deserialize(json) as List&lt;object&gt;;
                for (int i = 0; i &lt; monsterData.Count; ++i)
                {
                    Dictionary&lt;string, object&gt; data = monsterData[i] as Dictionary&lt;string, object&gt;;
                    string prefab = (string)(data[&quot;Prefab&quot;]);
                    Monster monster = Add(mapping[prefab]);
                    monster.Load(data);
                }
            }
        }

        void Clear()
        {
            for (int i = monsters.Count - 1; i &gt;= 0; --i)
                Destroy(monsters[i].gameObject);
            monsters.Clear();
        }
    }
}
</code></pre>

<hr />

<p>En esta versión, ya no necesito la referencia al único objeto Monster. Dado que estamos creando dinámicamente desde una variedad de tipos de monstruos, necesito referencias a los prefabricados que podemos crear una instancia (línea 8). Estos podrían haberse obtenido a través de Resources.Load, pero esta versión es aceptable por ahora. No te olvides de asignarlos en el editor.</p>

<p>A continuación, creé un diccionario para mapear desde un nombre prefabricado al propio prefabricado (línea 9): esa configuración se produce en el método de inicio (líneas 14-15). Este paso puede parecer un poco redundante, pero encuentro que el código es un poco más legible (sin mencionar más eficiente) que el código que necesita buscar una coincidencia en el array (muchas comparaciones de cadenas = LENTO).</p>

<p>Solo modifiqué ligeramente el código OnGUI. Reemplacé el botón que movía el monstruo original, con un botón para crear nuevos monstruos dinámicos que ya se moverán.</p>

<p>El método &ldquo;Randomize&rdquo; ahora requiere que se le pase un parámetro de Monster, ya que queremos poder mover cualquiera de nuestros monstruos con el mismo código.</p>

<p>El método &ldquo;AddRandom&rdquo; es nuevo y elige uno de los prefabricados al azar para crear. Luego se asegura de que el monstruo recién creado se aleatorice con el método mencionado anteriormente.</p>

<p>El método &ldquo;Add&rdquo; toma un prefabricado como parámetro, desde el cual instanciará un nuevo monstruo. El script de monstruo almacena una referencia al nombre del prefab que se utilizó, por lo que podemos usar el mismo prefab de nuevo más tarde cuando necesitamos persistir realmente en el objeto. Después de instanciar el monstruo, obtenemos una referencia al script de monstruo (tenga en cuenta que GetComponent funcionará porque nuestras versiones de Subclass de Monster todavía son componentes de Monster) y agrega el componente a una lista para que podamos seguir y administrar todo lo que tenemos creado.</p>

<p>El método &ldquo;Save&rdquo; es similar a la versión anterior, pero ahora estamos creando una lista de objetos de diccionario, en lugar de un solo diccionario. Nuestro serializador JSON puede serializar todo el conjunto como una cadena, por lo que podemos pegarlo fácilmente en un PlayerPref como lo hicimos antes. Tenga en cuenta que utilicé una clave pluralizada esta vez para mayor claridad.</p>

<p>El método &ldquo;Load&rdquo; cambió un poco más, pero no está mal. Primero destruyo cualquier monstruo existente antes de crear uno nuevo de acuerdo con los datos de Guardar. Tenga en cuenta que esto es más fácil que un sistema Queue, pero una cola de objetos reutilizables es más ideal en el código de producción. La otra gran diferencia (además de trabajar con una lista de diccionarios) es que obtengo una referencia al nombre prefabricado dentro de cada entrada y crea una instancia de un nuevo objeto en consecuencia. Luego cargo los datos correspondientes en el objeto engendrado. Esto es importante porque un Monstruo Rojo no se cargaría correctamente si se pasara los datos de un Monstruo Azul y viceversa.</p>

<p>Siéntete libre de correr la escena y probarlo todo. Agregue un montón de monstruos, guarde los datos (tenga en cuenta que también registro una versión de la salida JSON en la consola en caso de que quiera inspeccionarlo) y luego intente detener e iniciar una nueva sesión. ¡Todos tus monstruos dinámicamente creados vuelven a cargar bien!</p>

<h1 id="archivos">Archivos</h1>

<p>Si está guardando muchos datos, o si tiene sentido dividirlos en trozos más pequeños que se pueden cargar en diferentes momentos, entonces puede tener sentido escribir en archivos en lugar de poner demasiado en PlayerPrefs.</p>

<p>También usaremos el espacio de nombres System.IO.</p>

<p>Usando el mismo ejemplo anterior, puede modificar solo los métodos Guardar y Cargar de la siguiente manera:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using MiniJSON;
using System.IO;
#endregion

namespace MoonAntonio
{
    public class Archivo : MonoBehaviour 
    {
        [SerializeField] GameObject[] prefabs;
        Dictionary&lt;string, GameObject&gt; mapping = new Dictionary&lt;string, GameObject&gt;();
        List&lt;Monster&gt; monsters = new List&lt;Monster&gt;();

        void Start()
        {
            for (int i = 0; i &lt; prefabs.Length; ++i)
                mapping.Add(prefabs[i].name, prefabs[i]);
            Load();
        }

        void OnGUI()
        {
            if (GUI.Button(new Rect(10, 10, 100, 30), &quot;Agregar&quot;))
                AddRandom();

            if (GUI.Button(new Rect(10, 50, 100, 30), &quot;Guardar&quot;))
                Save();

            if (GUI.Button(new Rect(10, 90, 100, 30), &quot;Cargar&quot;))
                Load();
        }

        void Randomize(Monster monster)
        {
            monster.HP = UnityEngine.Random.Range(10, 100);
            float x = UnityEngine.Random.Range(-10f, 10f);
            float y = UnityEngine.Random.Range(-10f, 10f);
            float z = UnityEngine.Random.Range(-10f, 10f);
            monster.transform.localPosition = new Vector3(x, y, z);
        }

        void AddRandom()
        {
            GameObject prefab = prefabs[UnityEngine.Random.Range(0, prefabs.Length)];
            Monster monster = Add(prefab);
            Randomize(monster);
        }

        Monster Add(GameObject prefab)
        {
            GameObject instance = Instantiate(prefab) as GameObject;
            Monster monster = instance.GetComponent&lt;Monster&gt;();
            monster.name = prefab.name;
            monsters.Add(monster);
            return monster;
        }

        void Save()
        {
            var monsterData = new List&lt;Dictionary&lt;string, object&gt;&gt;(monsters.Count);
            for (int i = 0; i &lt; monsters.Count; ++i)
                monsterData.Add(monsters[i].Save());

            string json = Json.Serialize(monsterData);
            string filePath = Application.persistentDataPath + &quot;/Monsters.txt&quot;;
            File.WriteAllText(filePath, json);
        }

        void Load()
        {
            Clear();
            string filePath = Application.persistentDataPath + &quot;/Monsters.txt&quot;;
            if (File.Exists(filePath))
            {
                string json = File.ReadAllText(filePath);
                var monsterData = Json.Deserialize(json) as List&lt;object&gt;;
                for (int i = 0; i &lt; monsterData.Count; ++i)
                {
                    Dictionary&lt;string, object&gt; data = monsterData[i] as Dictionary&lt;string, object&gt;;
                    string prefab = (string)(data[&quot;Prefab&quot;]);
                    Monster monster = Add(mapping[prefab]);
                    monster.Load(data);
                }
            }
        }

        void Clear()
        {
            for (int i = monsters.Count - 1; i &gt;= 0; --i)
                Destroy(monsters[i].gameObject);
            monsters.Clear();
        }
    }
}
</code></pre>

<hr />

<p><center><img src="/img/codebackdoor/learncsharpunity/10.gif" alt="009" /></center></p>

<h1 id="resumen">Resumen</h1>

<p>En esta lección cubrimos algunos métodos de persistencia de datos. Primero cubrimos la persistencia temporal a través de clases estáticas, el patrón de diseño de Singleton y Unity GameObjects que puede sobrevivir a los cambios de escena. Luego exploramos cómo pueden persistir los datos incluso en múltiples sesiones de juego a través de PlayerPrefs, serialización JSON y escritura de datos en archivos. Incluso conseguimos un poco de fantasía al insistir en una lista de objetos polimórficos creados dinámicamente.</p>

<p><center><a href="http://bit.ly/2BGWkzn" class="button"><i class="fa fa-caret-right" aria-hidden="true"></i> Siguiente - Enums y Flags</a></p>

<p><center><img src="/img/ref.png" alt="001" /></center></p>


		
	</section>
    </div>

    <footer class="site-footer">
	<p class="text">&copy; 2022 - Moon Antonio</p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-89564434-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
