<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>Aprende C# con Unity - Genéricos&middot; Antonio Moon´s</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Moon Antonio">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Antonio,Dev,Game">
	<meta name="generator" content="Hugo 0.50" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://moonantonio.github.io/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://moonantonio.github.io/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="site-header">
	<div class="branding">
		<a href="https://moonantonio.github.io/">
		<img class="avatar" src="https://moonantonio.github.io/img/avatar.png" alt="avatar"/>
		</a>
		<h1 class="site-title">
			<i class="fa fa-angle-right"></i>
			<a href="https://moonantonio.github.io/">Antonio Moon´s</a>
			<span class="logo-cursor "></span>
		</h1>
	</div>
	<nav class="site-nav">

		<ul>
			<li><a href="/about/">  </a></li>

			<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/devblog/" title="devBlog">
  		</i>&nbsp; devBlog</a> <i class="fa fa-gamepad" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/backdoor" title="BackDoor">
  		</i>&nbsp; BackDoor</a> <i class="fa fa-black-tie" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://github.com/MoonAntonio/rec.repos" title="Public">
  		</i>&nbsp; Publico</a> <i class="fa fa-code" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/portfolio/" title="About">
  		</i>&nbsp; About</a> <i class="fa fa-terminal" aria-hidden="true"></i>
  </a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="&#43;">
		</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
	</a>
</li>

<li>
	<a href="https://moonantonio.github.io/" title="">
		<i class="fa fa-fw fa-home"></i>
	</a>
</li>

<li>
	<a href="https://moonantonio.github.io/index.xml" title="Subcribe">
		<i class="fa fa-fw fa-rss"></i>
	</a>
</li>

<li>
	<a href="mailto:antoniomt.moon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>



<li>
	<a href="https://bitbucket.org/MoonAntonio" title="Bitbucket">
		<i class="fa fa-fw fa-bitbucket"></i>
	</a>
</li>







<li>
	<a href="https://github.com/MoonAntonio" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























<li>
	<a href="https://trello.com/antoniomoon" title="Trello">
		<i class="fa fa-fw fa-trello"></i>
	</a>
</li>

<li>
	<a href="https://gitlab.com/MoonAntonio" title="Gitlab">
		<i class="fa fa-fw fa-gitlab"></i>
	</a>
</li>

		</ul>
	</nav>
</header>

    <div class="content">
    <article class="feature-image">
		<header style="background-image: url('https://moonantonio.github.io/img/img103.png')">
			<h1 class="title">Aprende C# con Unity - Genéricos</h1>
		</header>

	<section class="post-content">
		

<p>Los genéricos proporcionan una forma de hacer una especie de &ldquo;plantilla&rdquo; de su código que funciona de la misma manera en una variedad de tipos de datos diferentes. Si bien podría considerarse un tema más avanzado, existen algunos beneficios importantes al usarlos desde el principio. En esta lección, presentaré listas genéricas y diccionarios, y mostraré cómo se usan los genéricos para funcionalidades específicas de Unity, como obtener componentes y cargar recursos. Si te sientes aventurero, no dudes en echar un vistazo a algunos ejemplos rápidos de clases y métodos genéricos personalizados al final.</p>

<p><center><a href="https://github.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-github-alt"></i>GitHub Repo</a><a href="https://gitlab.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-gitlab"></i>GitLab Repo</a></center></p>

<h1 id="lista-genérica">Lista genérica</h1>

<p>Si has hecho alguna prueba con matrices, es posible que hayas topado con algunas características de la lista de deseos. Por ejemplo, es posible que se haya sentido decepcionado al ver que son &ldquo;inmutables&rdquo;, lo que significa que no puede cambiar el tamaño añadiendo o eliminando objetos de forma dinámica. Muchas de las funciones que está esperando se excluyen por el bien del rendimiento. Si está escribiendo un código altamente optimizado, como una inteligencia artificial compleja para jugar al Ajedrez, entonces querrá esa velocidad extra. En la mayoría de los otros casos, los beneficios de opciones son un poco menos eficaces, pero más robustos.</p>

<p>La lista genérica es muy parecida a una matriz. Gran parte de la sintaxis para leer y escribir se verá igual también. Sin embargo, una lista puede agregar o eliminar elementos dinámicamente, indicarle el índice de un elemento que contiene, ordenar, etc. Veamos cómo se ve en el código:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
#endregion

namespace MoonAntonio
{
    public class ListExamples : MonoBehaviour 
    {
        public List&lt;int&gt; indices = new List&lt;int&gt;();

        void Start()
        {
            for (int i = 0; i &lt; 10; ++i)
            {
                int index = UnityEngine.Random.Range(0, 10);
                Debug.Log(&quot;Agregada entrada: &quot; + index);
                indices.Add(index);
            }

            if (indices.Contains(3))
            {
                Debug.Log(&quot;Eliminada entrada.&quot;);
                indices.Remove(3);
            }

            indices.Sort();
            Debug.Log(&quot;Entradas ordenadas ... Ahora:&quot;);

            for (int i = 0; i &lt; indices.Count; ++i)
            {
                int index = indices[i];
                Debug.Log(string.Format(&quot;i: &quot; + index));
            }
        }
    }
}
</code></pre>

<hr />

<p>En primer lugar, tenga en cuenta que en la línea 3, he especificado que estoy usando un nuevo espacio de nombres, &ldquo;System.Collections.Generic&rdquo;. Esto nos permite declarar y usar genéricos sin especificarlos completamente. Por ejemplo, sin la instrucción using, la línea 7 se vería así en su lugar:</p>

<hr />

<pre><code class="language-C#">public System.Collections.Generic.List&lt;int&gt; indices = new System.Collections.Generic.List&lt;int&gt;();
</code></pre>

<hr />

<p>Declaramos nuestra lista en la línea 7 y la inicializamos como una lista vacía. Esto es genial para mostrar que no necesita saber qué tan grande será su lista, o qué elementos específicos contendrá. La parte &ldquo;genérica&rdquo; ​​de la línea se ve entre &ldquo; &lt;&rdquo; y &ldquo; &gt;&rdquo; donde especificamos un tipo de datos; en este ejemplo usamos un &ldquo;int&rdquo;. Esto significa que esta lista en particular solo puede contener valores int. Debido a que todos los elementos de la lista están obligados a ser del mismo tipo de datos, el código se ejecutará de forma más segura y rápida. Lo llamamos genérico porque podemos pasar cualquier tipo de DataType (a veces hay excepciones a esta regla) en la declaración. Una lista de float, string o Transform se declararía de manera similar:</p>

<hr />

<pre><code class="language-C#">List&lt;float&gt; list1 = new List&lt;float&gt;();
List&lt;string&gt; list2 = new List&lt;string&gt;();
List&lt;Transform&gt; list3 = new List&lt;Transform&gt;();
</code></pre>

<hr />

<p>En el método de inicio, ejecuté una variedad de tareas en nuestra lista e imprimí mensajes a la consola explicando lo que estaba sucediendo. Primero, uso un bucle for para generar y agregar 10 números aleatorios a nuestra lista. Los hice al azar para mostrar que la lista puede contener valores duplicados, y para ayudar a ilustrar el hecho de que puedo agregar valores fuera de orden y ordenarlos más tarde.</p>

<p>Luego, en la línea 21, verifico si agregamos alguna entrada del número 3. Si lo hicimos, eliminamos ese valor. (Tenga en cuenta que en este ejemplo solo elimino la primera ocurrencia que encuentro, pero podría haber más).</p>

<p>En la línea 27, le digo a la lista que se ordene a sí misma: de manera predeterminada, ordenará sus elementos en orden ascendente. Hay otras formas de ordenar los elementos que puede investigar más adelante.</p>

<p>Finalmente, en la línea 30 hago otro ciclo para imprimir los elementos en orden tal como aparecen después de haberlos ordenado. Con suerte, debería reconocer la sintaxis del paréntesis para leer un elemento en un índice, porque es lo mismo que trabajar con una matriz.</p>

<p>Copie el código de ejemplo y luego adjunte su script a un objeto en escena. Ejecute la escena y revise la salida en la ventana de la consola. En una ejecución de muestra, vi que agregué los siguientes índices: (1, 1, 7, 8, 3, 6, 1, 5, 0, 2), luego vi que se eliminó una entrada y luego vi las entradas ordenados como (0, 1, 1, 1, 2, 5, 6, 7, 8).</p>

<h1 id="diccionario-genérico">Diccionario genérico</h1>

<p>Un diccionario es otro tipo de recopilación de datos utilizada por los programadores. A diferencia de una matriz o lista, se considera desordenada, y se accede mediante una &ldquo;clave&rdquo; en lugar de un &ldquo;índice&rdquo;. Ciertos escenarios pueden hacer que esto se sienta más natural, porque hacer referencia a un objeto por índice no significa necesariamente nada. Por ejemplo, si tengo una lista de GameObject, entonces intuitivamente no sé que GameObject en el índice 0 representa un subordinado y que GameObject en el índice 1 representa un jefe. Sin embargo, al asociar un valor a una clave, la relación se vuelve más obvia y legible en su código.</p>

<p>Imagina que estás haciendo un juego de rol con una gran variedad de artículos de la tienda. Algunas tiendas solo pueden mostrar ciertos artículos en un momento dado, y los objetos que muestran pueden no estar basados ​​en ningún orden en particular. Si administraba sus artículos como una lista o como una matriz, cada vez que quisiera obtener una referencia a un artículo, tendría que &ldquo;recorrer&rdquo; cada elemento de la lista hasta que encuentre el que coincida. Con un diccionario, básicamente puedes decir, &ldquo;dame el elemento llamado &lsquo;Daga&rsquo;&rdquo; e inmediatamente obtén su referencia. Veamos cómo se ve en el código:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
#endregion

namespace MoonAntonio
{
    public class DictionaryExamples : MonoBehaviour 
    {
        public Dictionary&lt;string, int&gt; stats = new Dictionary&lt;string, int&gt;();

        void Start()
        {
            stats.Add(&quot;HP&quot;, 10);
            stats.Add(&quot;MP&quot;, 3);
            stats.Remove(&quot;MP&quot;);
            if (stats.ContainsKey(&quot;HP&quot;)) Debug.Log(string.Format(&quot;Tienes {0} puntos de golpe restantes&quot;, stats[&quot;HP&quot;]));
        }
    }
}
</code></pre>

<hr />

<p>En la línea 7, declaramos nuestro diccionario. Tenga en cuenta que declaramos que estamos utilizando el espacio de nombres &ldquo;System.Collections.Generic&rdquo; para usar la especificación más corta. Los diccionarios tienen una &ldquo;Clave&rdquo; y un &ldquo;Valor&rdquo;, cada uno de los cuales puede ser un tipo de dato diferente. Lo ilustro aquí haciendo que la &ldquo;clave&rdquo; sea un tipo de cadena, y el &ldquo;valor&rdquo; un tipo de &ldquo;int&rdquo;.</p>

<p>En el método de inicio, uso algunos de los métodos disponibles para los diccionarios. Primero agrego una clave y un valor para una estadística llamada &ldquo;HP&rdquo;. Luego agrego una estadística diferente llamada &ldquo;MP&rdquo;. Además de agregar pares clave-valor, puede eliminarlos, aunque en ese caso solo especifica la clave. Elimino la estadística &ldquo;MP&rdquo; en la línea 13. Cuando trabaje con diccionarios, es una buena idea verificar que un diccionario tenga una clave antes de intentar leerlo. Lo hago en la línea 14 antes de leer el valor con la sintaxis del paréntesis (de nuevo, similar a leer una matriz) al final de la línea 15.</p>

<p>Hay algunos inconvenientes con los que puede encontrarse al usar diccionarios que debe tener en cuenta:</p>

<ol>
<li>Unity no &ldquo;reconoce&rdquo; los diccionarios, por lo que incluso si lo marca como público, no se serializará ni aparecerá en el inspector. Tenga en cuenta que esto no le impide usarlos en sus scripts, pero sí crea un problema en la inicialización basada en el editor.</li>
<li>Si intenta utilizar la sintaxis Agregar (.Add (clave, valor)) a un diccionario que ya contiene esa clave, obtendrá un error: &ldquo;ArgumentException: ya existe un elemento con la misma clave en el diccionario&rdquo;. Puede cambiar un valor por el indexador como (diccionario [clave] = valor).</li>
<li>Si intenta escribir un valor de diccionario por indexador, y la clave no existe, agregará la clave y asignará el valor automáticamente.</li>
<li>Si intenta leer un valor de diccionario por indexador, y la clave no existe, obtendrá un error: &ldquo;KeyNotFoundException: la clave dada no estaba presente en el diccionario&rdquo;.</li>
<li>Si intenta establecer un valor de diccionario para el tipo de dato incorrecto, el compilador se quejará: &ldquo;error CS1502: la mejor coincidencia de método sobrecargado para &lsquo;System.Collections.Generic.Dictionary.Add (string, int)&rsquo; tiene algunos inválidos argumentos &ldquo;</li>
</ol>

<h1 id="genéricos-y-unity">Genéricos y Unity</h1>

<p>Aunque los ejemplos de genéricos que he dado hasta ahora se aplicaron específicamente a instancias de una clase (nuestra lista y variables de diccionario), debe saber que también se puede aplicar a declaraciones de métodos. Debido a los beneficios de los genéricos, los encontrarás diseminados a lo largo de la funcionalidad de Unity. El primer lugar que puede observar es con la capacidad de &ldquo;Agregar&rdquo; o &ldquo;Obtener&rdquo; componentes en un GameObject:</p>

<hr />

<pre><code class="language-C#">Foo foo = gameObject.AddComponent&lt;Foo&gt;();
Bar bar = gameObject.GetComponent&lt;Bar&gt;();
</code></pre>

<hr />

<p>Estas dos líneas muestran cómo se usan los marcadores genéricos en los métodos AddComponent y GetComponent para especificar qué tipo de componente se agregará o recuperará. Tenga en cuenta que en el ejemplo, &ldquo;Foo&rdquo; y &ldquo;Bar&rdquo; son ejemplos de nombres de clases para los que habría necesitado crear scripts.</p>

<p>Al usar la primera línea, puede agregar una instancia de un script a GameObject mientras su juego se está ejecutando. Por ejemplo, puede agregar un script de Muerte a un objeto siempre que sus puntos de golpe se reduzcan a cero. También puede compilar objetos complejos en tiempo de ejecución en lugar de en tiempo de edición para asegurarse de que el orden en que se agregan le permita configurar correctamente todas las dependencias de un objeto. Por ejemplo, si Foo necesita una referencia a Bar, entonces debe asegurarse de que Bar se haya agregado primero al objeto.</p>

<p>La segunda línea devuelve una instancia de un script en un GameObject (o null si no puede encontrar uno). Puede usar esto para probar si una referencia a un objeto tiene un componente que está buscando y, de ser así, realice algún tipo de acción sobre él (consulte sus propiedades públicas o utilice sus métodos públicos).</p>

<p>También verá una sintaxis similar al cargar recursos:</p>

<hr />

<pre><code class="language-C#">TextAsset data = Resources.Load&lt;TextAsset&gt;(&quot;Level_0&quot;);
</code></pre>

<hr />

<p>Tenga en cuenta que para que esa línea funcione, necesitará un asset de texto con el nombre correcto en su proyecto dentro de una carpeta llamada &ldquo;Resources&rdquo;. Es posible tener múltiples tipos diferentes de assets que comparten el mismo nombre, como un prefabricado y un elemento de imagen, pero cuando especifica el tipo de objeto que se cargará como argumento genérico, devolverá el elemento correcto.</p>

<h1 id="métodos-genéricos-personalizados">Métodos genéricos personalizados</h1>

<p>A estas alturas ya se estará preguntando cómo crear su propio método genérico. Considere los siguientes ejemplos:</p>

<hr />

<pre><code class="language-C#">void ToggleComponent&lt;T&gt; () where T : MonoBehaviour {
    T t = gameObject.GetComponent&lt;T&gt;();
    if (t)
        t.enabled = !t.enabled;
}
 
T FindOrAdd&lt;T&gt; () where T : MonoBehaviour {
    T t = gameObject.GetComponent&lt;T&gt;();
    if (t == null)
        t = gameObject.AddComponent&lt;T&gt;();
    return t;
}
</code></pre>

<hr />

<p>Una declaración de método genérico comienza como cualquier otro método que haya declarado, sin embargo, el marcador de tipo genérico &ldquo;&lt;&ldquo;T&rdquo;&gt;&rdquo; se inserta justo antes del paréntesis. El valor que coloca dentro del marcador genérico es similar al nombre de un parámetro, pero se usa para referirse al &ldquo;Tipo de datos&rdquo; que se usará dentro del método. Tenga en cuenta que puede volver a utilizar el mismo identificador como el tipo de datos para el tipo de devolución del método o como un tipo de datos en un parámetro que acepta el método.</p>

<p>Después del paréntesis hay algo llamado &ldquo;restricción&rdquo;, un bit de código opcional que se aplica a los tipos de datos sobre los que permitimos que funcione este método. En este ejemplo, especificamos que los métodos solo pueden funcionar con tipos de datos que son, o derivan de, la clase base MonoBehaviour. Debido a nuestra restricción, podemos escribir cualquier código dentro del método que se aplique a cualquier comportamiento en mono, como la capacidad de alternar si está habilitado o no. Sin la restricción, el compilador no sabría ningún detalle del objeto y no podría escribir una implementación tan específica.</p>

<h1 id="clases-genéricas-personalizadas">Clases genéricas personalizadas</h1>

<p>También puedes hacer una clase Genérica. De hecho, así es como se crearían la Lista y el Diccionario que utilizamos anteriormente:</p>

<hr />

<pre><code class="language-C#">using System;
 
public class InfoEventArgs&lt;T&gt; : EventArgs {
    public T info;
 
    public InfoEventArgs() {
        info = default(T);
    }
 
    public InfoEventArgs (T info) {
        this.info = info;
    }
}
</code></pre>

<hr />

<p>Esta clase se convierte en una especie de plantilla para una subclase de EventArgs que contiene una única propiedad, pero esa propiedad puede ser de cualquier tipo. Este ejemplo muestra dos &ldquo;constructores&rdquo; que son un tipo especial de método que crea una instancia de una clase. Cuando inicializamos nuestro diccionario usando &ldquo;nuevo diccionario&rdquo;, estábamos llamando a un constructor. Se puede decir que un método es un constructor porque no tiene un tipo de retorno en su firma y porque el nombre del método es el mismo nombre que el nombre de la clase.</p>

<p>El primer constructor es un constructor predeterminado, no toma un parámetro. Como no utilicé ninguna restricción en esta clase, el tipo de datos podría ser un tipo de valor (como un int) o un tipo de referencia (como un GameObject), cada uno de los cuales tiene valores predeterminados diferentes e incompatibles: no puedo asignar un &ldquo;GameObject&rdquo; un valor de &ldquo;0&rdquo; y no puedo asignarle un valor &ldquo;null&rdquo; a &ldquo;int&rdquo;. La palabra clave &ldquo;default&rdquo; me resuelve este problema e inicia automáticamente un tipo genérico para mí.</p>

<p>En el segundo constructor, inicio la variable &ldquo;info&rdquo; a cualquier valor que pase el usuario. Utilicé una palabra clave especial &ldquo;this&rdquo;, que es una forma de que un script se refiera a sí mismo. El uso de la notación de puntos en la palabra clave &ldquo;this&rdquo; me permite diferenciar entre la variable &ldquo;info&rdquo; de la instancia y el parámetro &ldquo;info&rdquo; del constructor, ya que comparten el mismo nombre. Tenga en cuenta que también podría haberlos diferenciado dando al parámetro un nombre diferente.</p>

<p><center><img src="/img/codebackdoor/learncsharpunity/07.gif" alt="006" /></center></p>

<h1 id="resumen">Resumen</h1>

<p>En esta lección, presentamos una nueva función de lenguaje llamada genéricos. Los genéricos se pueden aplicar a métodos y clases como una forma de ayudar a que el código se pueda volver a usar en una variedad de DataTypes de una manera segura y rápida. Introduje la lista genérica y el diccionario, mostré cómo Unity usa los genéricos en sus propias bibliotecas y, finalmente, mostré cómo crear clases y métodos genéricos personalizados, con o sin restricciones.</p>

<p><center><a href="http://bit.ly/2wnT4TG" class="button">Siguiente - Corutinas</a></p>


		
	</section>
    </div>

    <footer class="site-footer">
	<p class="text">&copy; 2022 - Moon Antonio</p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-89564434-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
