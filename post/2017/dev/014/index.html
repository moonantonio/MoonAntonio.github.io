<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>MVC simplificado&middot; Antonio Moon´s</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Moon Antonio">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Antonio,Dev,Game">
	<meta name="generator" content="Hugo 0.50" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://moonantonio.github.io/css/main.css">
	<link id="dark-mode-theme" rel="stylesheet" href="/css/dark.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://moonantonio.github.io/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="site-header">
	<div class="branding">
		<a href="https://moonantonio.github.io/">
		<img class="avatar" src="https://moonantonio.github.io/img/avatar.png" alt="avatar"/>
		</a>
		<h1 class="site-title">
			<i class="fa fa-angle-right"></i>
			<a href="https://moonantonio.github.io/">Antonio Moon´s</a>
			<span class="logo-cursor "></span>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			<li><a href="/about/">  </a></li>

			<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/devblog/" title="devBlog">
  		</i>&nbsp; devBlog</a> <i class="fa fa-gamepad" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/backdoor" title="backDoor">
  		</i>&nbsp; backDoor</a> <i class="fa fa-black-tie" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://github.com/MoonAntonio/rec.repos" title="src">
  		</i>&nbsp; src</a> <i class="fa fa-code" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/portfolio/" title="moon">
  		</i>&nbsp; moon</a> <i class="fa fa-terminal" aria-hidden="true"></i>
  </a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="&#43;">
		</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
	</a>
</li>





<li>
	<a href="mailto:antoniomt.moon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>











<li>
	<a href="https://github.com/MoonAntonio" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























<li>
	<a href="https://gitlab.com/MoonAntonio" title="Gitlab">
		<i class="fa fa-fw fa-gitlab"></i>
	</a>
</li>

<li>
	<a href="https://trello.com/antoniomoon" title="Trello">
		<i class="fa fa-fw fa-trello"></i>
	</a>
</li>



			<a id="dark-mode-toggle" class="fa fa-moon-o" title="darkmode"></a>
		</ul>
	</nav>
</header>

    <div class="content">
    <script src="https://moonantonio.github.io/js/darkmode.js"></script>
	<article class="feature-image">
		<header style="background-image: url('https://moonantonio.github.io/img/b/b040.jpg')">
			<h1 class="title">MVC simplificado</h1>
		</header>

	<section class="post-content">
		

<p>Los <strong>programadores principiantes</strong> generalmente comienzan a aprender el oficio con el Hello World. A partir de ahí, <strong>sin un patrón de diseño</strong>, se suele aumentar sin ninguna metodología los proyectos y terminan siendo un caos. Cada nuevo desafío lleva a casa <strong>una lección importante</strong>:</p>

<p>Cuanto más grande es el proyecto, más grande es el espagueti.</p>

<p><center><img src="/img/c/mvc01.jpg" alt="001" /></center></p>

<hr />

<p>Es fácil ver que en equipos grandes o pequeños, uno no puede hacer imprudentemente lo que le plazca. El código debe <strong>mantenerse</strong> y puede durar mucho tiempo. Las empresas para las que ha trabajado no pueden simplemente buscar su información de contacto y preguntarle cada vez que quieren corregir o mejorar la base de código (y tampoco desean que lo hagan).</p>

<p>Es por eso que existen <strong>patrones de diseño</strong> de software, imponen reglas simples para dictar la estructura general de un proyecto de software. Ayudan a uno o más programadores a separar las piezas principales de un proyecto grande y organizarlas de manera estandarizada, eliminando la confusión cuando se encuentra una parte desconocida de la base de código.</p>

<p><center><img src="/img/c/mvc02.jpg" alt="002" /></center></p>

<hr />

<p>Estas reglas, cuando son seguidas por todos, <strong>permiten que el código heredado se mantenga</strong> y navegue mejor y que el código nuevo se agregue más rápidamente. Se gasta menos tiempo planificando la metodología de desarrollo. Uno debe considerar cuidadosamente los puntos fuertes y débiles de cada patrón, y encontrar la mejor opción para el desafío en cuestión.</p>

<p>Relataré mi experiencia con el desarrollo de juegos Unity y el patrón Model-View-Controller (MVC) para el desarrollo de juegos. En mis siete años de desarrollo, habiendo luchado con <strong>mi parte justa de espagueti de desarrollo de juegos</strong>, he logrado una gran estructura de código y velocidad de desarrollo usando este patrón de diseño.</p>

<p>Empezaré explicando un poco de la arquitectura base de Unity, el patrón Entity-Component. Luego continuaré explicando cómo se ajusta MVC en la capa superior de la misma, y ​​usaré un pequeño proyecto simulado como ejemplo.</p>

<h1 id="motivación">Motivación</h1>

<p>En la <strong>literatura del software</strong> encontraremos una gran cantidad de <strong>patrones de diseño</strong>. A pesar de que tienen un conjunto de reglas, los desarrolladores usualmente harán un poco de flexión de reglas para <strong>adaptar mejor el patrón a su problema</strong> específico.</p>

<p>Esta <strong>&ldquo;libertad de programación&rdquo;</strong> es una prueba de que aún no hemos encontrado <strong>un método único</strong> y definitivo para diseñar software. Por lo tanto, este artículo <strong>no pretende ser la solución definitiva</strong> para su problema, sino más bien, para mostrar los beneficios y las posibilidades de dos patrones bien conocidos: <strong>Entity-Component</strong> y <strong>Model-View-Controller</strong>.</p>

<hr />

<h1 id="el-patrón-de-entity-component-entidad-componente">El patrón de Entity-Component(Entidad-Componente)</h1>

<p>Entity-Component (EC) es un <strong>patrón de diseño</strong> donde primero definimos la <strong>jerarquía de los elementos</strong> que componen la aplicación (Entidades), y luego, definimos las <strong>características y los datos</strong> que cada uno contendrá (Componentes). En términos más de &ldquo;programadores&rdquo;, una entidad puede ser un objeto con una matriz de 0 o más componentes. Vamos a representar una entidad como esta:</p>

<pre><code class="language-C#">entidad [componente0, componente1, ...]
</code></pre>

<p>Aquí hay un ejemplo simple de un árbol EC.</p>

<pre><code class="language-C#">- app [Aplicacion]
   - game [Game]
      - player [KeyboardInput, Renderer]
      - enemigos
         - araña [ArañaAI, Renderer]
         - ogro [OgreAI, Renderer]
      - ui [UI]
         - hud [HUD, MouseInput, Renderer]
         - pause-menu [PauseMenu, MouseInput, Renderer]
         - victory-modal [VictoryModal, MouseInput, Renderer]
         - defeat-modal [DefeatModal, MouseInput, Renderer]
</code></pre>

<p>EC <strong>es un buen patrón</strong> para aliviar los problemas de herencia múltiple, donde una estructura de clase compleja puede introducir problemas como el <strong>problema de diamante</strong> donde una clase D, heredando dos clases, B y C, con la misma clase base A, puede introducir conflictos porque B y C modifican las características de A de manera diferente.</p>

<p><center><img src="/img/c/mvc03.jpg" alt="003" /></center></p>

<p>Este tipo de problemas pueden ser comunes en el desarrollo de juegos donde la herencia se usa a menudo extensivamente.</p>

<p>Al desglosar las características y los manejadores de datos en componentes más pequeños, se pueden adjuntar y reutilizar en diferentes entidades sin depender de la herencia múltiple (que, dicho sea de paso, ni siquiera es una característica de C# o Javascript, los principales idiomas utilizados por Unity)</p>

<h3 id="donde-el-componente-de-la-entidad-se-queda-corto">Donde el componente de la entidad se queda corto</h3>

<p>Viendo un <strong>nivel por encima de POO</strong>, EC ayuda a <strong>desfragmentar y organizar mejor la arquitectura</strong> de su código. Sin embargo, en proyectos grandes todavía somos &ldquo;demasiado libres&rdquo; y podemos encontrarnos en un &ldquo;océano de características&rdquo;, teniendo dificultades para encontrar las Entidades y Componentes correctos, o averiguando cómo deben interactuar. Hay infinitas formas de ensamblar entidades y componentes para una tarea determinada.</p>

<p><center><img src="/img/c/mvc04.jpg" alt="004" /></center></p>

<hr />

<p>Una forma de <strong>evitar un desastre</strong> es imponer algunas pautas adicionales sobre Entity-Component. Por ejemplo, una forma en que <strong>me gusta pensar</strong> sobre el software es dividirlo en tres categorías diferentes:</p>

<ul>
<li>Algunos manejan los <strong>datos brutos</strong>, lo que permite su creación, lectura, actualización, eliminación o búsqueda (es decir, el concepto CRUD ).</li>
<li>Otros implementan la <strong>interfaz</strong> para que interactúen otros elementos, detectando eventos relacionados con su alcance y disparando notificaciones cuando ocurren.</li>
<li>Finalmente, algunos elementos son responsables de <strong>recibir estas notificaciones</strong>, tomar decisiones de lógica y decidir cómo se deben manipular los datos.</li>
</ul>

<p>Afortunadamente, ya tenemos un patrón que se comporta de esta manera exacta.</p>

<h1 id="el-patrón-model-view-controller-modelo-vista-controlador-mvc">El patrón Model-View-Controller (Modelo-Vista-Controlador) (MVC)</h1>

<p>El patrón Model-View-Controller (MVC) <strong>divide el software en tres componentes</strong> principales: <strong>Modelos</strong> (CRUD de datos), <strong>Vistas</strong> (Interfaz / Detección) y <strong>Controladores</strong> (Decisión / Acción). MVC es lo suficientemente flexible como para implementarse incluso en ECS o POO.</p>

<p>El desarrollo del juego y la interfaz de usuario tiene el flujo de trabajo habitual de esperar la entrada de un usuario u otra condición desencadenante, el envío de notificaciones de esos eventos en algún lugar, decidir qué hacer en respuesta y actualizar los datos en consecuencia. Estas acciones muestran claramente la compatibilidad de estas aplicaciones con MVC.</p>

<p>Esta <strong>metodología introduce otra capa de abstracción</strong> que ayudará con la planificación del software, y también permitirá a los nuevos programadores navegar incluso en una base de código más grande. Al dividir el proceso de pensamiento en datos, interfaz y decisiones, los desarrolladores pueden <strong>reducir el número de archivos fuente</strong> que se deben buscar para agregar o corregir la funcionalidad.</p>

<h3 id="unity-y-ec">Unity y EC</h3>

<p>Primero veamos de cerca lo que Unity nos da por adelantado.</p>

<p>Unity es una plataforma de desarrollo <strong>basada en CE</strong>, donde todas las entidades son instancias GameObject y las características que las hacen ser &ldquo;visibles&rdquo;, &ldquo;movibles&rdquo;, &ldquo;interactivas&rdquo;, etc., son proporcionadas por las clases que se extienden <strong><Component></strong>.</p>

<p>El panel de jerarquía y el panel Inspector del editor de Unity proporcionan una forma poderosa de ensamblar su aplicación, adjuntar componentes, configurar su estado inicial y arrancar su juego con mucho menos código fuente de lo que lo haría normalmente.</p>

<p>Aún así, como hemos discutido, podemos abordar el problema de las &ldquo;demasiadas características&rdquo; y nos encontramos en una jerarquía gigantesca, con características diseminadas por todas partes, lo que hace que la vida de un desarrollador sea mucho más difícil.</p>

<p>Pensando de la manera MVC, podemos, en cambio, comenzar <strong>dividiendo las cosas según su función</strong>, estructurando nuestra aplicación.</p>

<h3 id="adaptación-de-mvc-a-un-entorno-de-desarrollo-de-juegos">Adaptación de MVC a un entorno de desarrollo de juegos</h3>

<p>Ahora, me gustaría introducir dos pequeñas modificaciones en el patrón MVC genérico, que ayudan a <strong>adaptarlo a las situaciones únicas</strong> en las que me he encontrado construyendo proyectos de Unity con MVC:</p>

<p>1- Las referencias de la clase MVC se dispersan fácilmente por todo el código.</p>

<ul>
<li>Dentro de Unity, los desarrolladores generalmente deben arrastrar y soltar instancias para hacer que sean accesibles, o bien llegar a ellos a través de sentencias como find, GetComponent( &hellip; ).</li>
<li>El infierno de referencia perdida se producirá si la Unidad se bloquea o algún error hace desaparecer todas las referencias arrastradas.</li>
<li>Esto hace que sea necesario tener un único objeto de referencia raíz, a través del cual se puede llegar y recuperar a todas las instancias en la Aplicación .</li>
</ul>

<p>2- Algunos elementos encapsulan funcionalidades generales que deberían ser altamente reutilizables, y que naturalmente no entran en una de las tres categorías principales de Modelo, Vista o Controlador. A estos me gusta llamarlos simplemente Componentes . También son &ldquo;Componentes&rdquo; en el sentido Entidad-Componente, pero simplemente actúan como ayudantes en el marco MVC.</p>

<ul>
<li>Por ejemplo, un Rotator Componente, que solo rota cosas con una velocidad angular determinada y no notifica, almacena ni decide nada.</li>
</ul>

<p>Para ayudar a aliviar estos dos problemas, se me ocurrió un patrón modificado que llamo AMVCC , o Application-Model-View-Controller-Component.</p>

<p><center><img src="/img/c/mvc05.jpg" alt="005" /></center></p>

<ul>
<li>Aplicación : punto de <strong>entrada único para su aplicación</strong> y contenedor de todas las instancias críticas y datos relacionados con la aplicación.</li>
<li>MVC : ya deberías saber esto. :)</li>
<li>Componente : scripts pequeños y bien contenidos que pueden <strong>reutilizarse</strong>.</li>
</ul>

<p>Estas dos modificaciones han satisfecho mis necesidades para todos los proyectos en los que los he usado.</p>

<h2 id="ejemplo-10-bounces">Ejemplo: 10 Bounces</h2>

<p>Como un simple ejemplo, veamos un pequeño juego llamado 10 Bounces , donde usaré los elementos centrales del patrón AMVCC.</p>

<p>La configuración del juego es simple: Un Ball con un SphereCollider y un Rigidbody(que comenzará a caer después de &ldquo;Jugar&rdquo;), un Cube como suelo y 5 scripts para componer el AMVCC.</p>

<h3 id="jerarquía">Jerarquía</h3>

<p>Antes de crear scripts, generalmente comienzo en la jerarquía y creo un esquema de mi clase y mis recursos. Siempre siguiendo este nuevo estilo AMVCC.</p>

<p><center><img src="/img/c/mvc06.jpg" alt="006" /></center></p>

<p>Como podemos ver, view GameObject contiene todos los elementos visuales y también los que tienen otros View scripts. El <strong>model y controller</strong> GameObjects, para proyectos pequeños, por lo general contienen solo sus respectivos scripts. Para proyectos más grandes, contendrán GameObjects con scripts más específicos.</p>

<p>Cuando alguien que navega por tu proyecto quiere acceder:</p>

<ul>
<li>Datos: ir a application &gt; model &gt; &hellip;</li>
<li>Lógica/Workflow: ir a application &gt; controller &gt; &hellip;</li>
<li>Representación/Interfaz/Detección: ir a application &gt; view &gt; &hellip;</li>
</ul>

<p>Si todos los equipos siguen <strong>estas simples reglas</strong>, los proyectos heredados no deberían convertirse en un problema.</p>

<p>Tenga en cuenta que no hay componentes contenedores, como ya hemos comentado, son más flexibles y se pueden unir a diferentes elementos en el ocio del desarrollador.</p>

<h3 id="scripting">Scripting</h3>

<blockquote>
<p><strong>Nota</strong>: Los scripts que se muestran a continuación son versiones abstractas de implementaciones del mundo real. Una implementación detallada no beneficiaría mucho al lector.</p>
</blockquote>

<p>Echemos un vistazo a la estructura de los scripts para el ejemplo.</p>

<p>Antes de comenzar, para aquellos que no estén familiarizados con el <strong>flujo de trabajo de Unity</strong>, aclaremos brevemente cómo funcionan los scripts y GameObjects juntos. En Unity, los &ldquo;Componentes&rdquo;, en el sentido Entidad-Componente, están representados por la clase MonoBehaviour. Para que uno exista durante el tiempo de ejecución, el desarrollador debe arrastrar y soltar su archivo fuente en un GameObject (que es la &ldquo;Entidad&rdquo; del patrón Entidad-Componente) o usar el comando AddComponent<TuMonobehaviour>(). Después de esto, el script será instanciado y listo para usar <strong>durante la ejecución</strong>.</p>

<p>Para comenzar, <strong>definimos la clase de aplicación</strong> (la &ldquo;A&rdquo; en AMVCC), que será la clase principal que contiene referencias a todos los elementos del juego instanciados. También crearemos una clase base auxiliar llamada Element, que nos da acceso a la instancia de la Aplicación y a sus instancias MVC hijos.</p>

<p>Con esto en mente, definamos la clase Application (la &ldquo;A&rdquo; en AMVCC), que tendrá una instancia única. En su interior, tres variables, model, view, y controller, nos darán puntos de acceso para todas las instancias de MVC en tiempo de ejecución. Estas variables deben ser MonoBehaviours con public referencias a los scripts deseados.</p>

<p>Luego, también <strong>crearemos una clase base auxiliar llamada Element</strong>, que nos da acceso a la instancia de la Aplicación. Este acceso permitirá que cada clase MVC llegue a todos los demás.</p>

<p>Tenga en cuenta que ambas clases extienden MonoBehaviour. Son &ldquo;Componentes&rdquo; que se adjuntarán a &ldquo;Entidades&rdquo; de GameObject.</p>

<pre><code class="language-C#">
// BounceApplication.cs

// Clase base para todos los elementos en esta aplicación.
public class BounceElement : MonoBehaviour
{
   // Da acceso a la aplicación y a todas las instancias.
   public BounceApplication app { get { return GameObject.FindObjectOfType&lt;BounceApplication&gt;(); }}
}

// 10 Bounces Punto de Entrada.
public class BounceApplication : MonoBehaviour
{
   // Referencia a las instancias de raíz del MVC.
   public BounceModel model;
   public BounceView view;
   public BounceController controller;

   // Init
   void Start() { }
}

</code></pre>

<p>Desde BounceElement podemos crear las clases principales de MVC. Las BounceModel, BounceView y BounceController, los <strong>scripts suelen actuar como contenedores</strong> para los casos más especializados, pero ya que este es un ejemplo sencillo sólo la vista tendrá una estructura anidada. El Modelo y el Controlador se p<strong>ueden hacer en un script</strong> para cada uno:</p>

<pre><code class="language-C#">
// BounceModel.cs

// Contiene todos los datos relacionados con la aplicación.
public class BounceModel : BounceElement
{
   // Data
   public int bounces;  
   public int winCondition;
}
</code></pre>

<hr />

<pre><code class="language-C#">
// BounceView .cs

// Contiene todas las vistas relacionadas con la aplicación.
public class BounceView : BounceElement
{
   // Referencia a la pelota
   public BallView ball;
}
</code></pre>

<hr />

<pre><code class="language-C#">// BallView.cs

// Describe la vista Bola y sus características.
public class BallView : BounceElement
{
   // Solo esto es necesario. La física hace el resto del trabajo.
   // Callback colision
   void OnCollisionEnter() { app.controller.OnBallGroundHit(); }
}

</code></pre>

<hr />

<pre><code class="language-C#">// BounceController.cs

// Controla el flujo de trabajo de la aplicación.
public class BounceController : BounceElement
{
   // Handles el evento de pelota golpeada
   public void OnBallGroundHit()
   {
      app.model.bounces++;
      Debug.Log(“Bounce ” + app.model.bounce);
      if(app.model.bounces &gt;= app.model.winCondition)
      {
         app.view.ball.enabled = false;
         app.view.ball.GetComponent&lt;RigidBody&gt;().isKinematic=true; // stops the ball
         OnGameComplete();
      } 
   }

   // Handles la condición de victoria
   public void OnGameComplete() { Debug.Log(“Victoria!!”); }
}

</code></pre>

<hr />

<p>Con todos los scripts creados, podemos proceder a adjuntarlos y configurarlos.</p>

<p>El diseño de la jerarquía debería ser así:</p>

<pre><code>- application [BounceApplication]
    - model [BounceModel]
    - controller [BounceController]
    - view [BounceView]
        - ...
        - ball [BallView]
        - ...
</code></pre>

<p>Usando BounceModel como ejemplo, podemos ver cómo se ve en el editor de Unity:</p>

<p><center><img src="/img/c/mvc07.jpg" alt="007" /></center></p>

<p>Con todos los scripts configurados y el juego funcionando, deberíamos obtener una salida en el panel de la consola .</p>

<h3 id="notificaciones">Notificaciones</h3>

<p>Como se muestra en el ejemplo anterior, cuando la pelota <strong>toca el suelo se ejecuta su vista</strong>, app.controller.OnBallGroundHit() que es un método. No es, de ninguna manera, &ldquo;incorrecto&rdquo; hacer eso para todas las notificaciones en la aplicación. Sin embargo, en mi experiencia, he logrado mejores resultados <strong>utilizando un sistema de notificación simpl</strong>e implementado en la clase de aplicación AMVCC.</p>

<p>Para implementar eso, actualicemos el diseño del BounceApplication:</p>

<pre><code class="language-C#">// BounceApplication.cs

class BounceApplication 
{
   // Itera todos los Controladores y delega los datos de notificación
   // Este método se puede encontrar fácilmente porque cada clase es &quot;BounceElement&quot; y 
   // tiene una instancia de &quot;aplicación&quot;.
   public void Notify(string p_event_path, Object p_target, params object[] p_data)
   {
      BounceController[] controller_list = GetAllControllers();
      foreach(BounceController c in controller_list)
      {
         c.OnNotification(p_event_path,p_target,p_data);
      }
   }

   // Obtiene todos los controladores de escena.
   public BounceController[] GetAllControllers() { /* ... */ }
}
</code></pre>

<p>A continuación, necesitamos un nuevo script donde todos los desarrolladores agregarán los nombres del evento de notificación, que se pueden enviar durante la ejecución.</p>

<pre><code class="language-C#">// BounceNotifications.cs

// Esta clase dará acceso estático a las cadenas de eventos.
class BounceNotification
{
   static public string BallHitGround = “ball.hit.ground”;
   static public string GameComplete  = “game.complete”;
   /* ...  */
   static public string GameStart     = “game.start”;
   static public string SceneLoad     = “scene.load”;
   /* ... */
}
</code></pre>

<p>Es fácil ver que, de esta forma, <strong>se mejora la legibilidad del código</strong> porque los desarrolladores no necesitan buscar en todo el código fuente los métodos controller.OnSomethingComplexName para comprender qué tipo de acciones pueden ocurrir durante la ejecución. Al solo verificar un archivo, es posible comprender el comportamiento general de la aplicación.</p>

<p>Ahora, solo tenemos que <strong>adaptar</strong> el BallView y BounceController para manejar este nuevo sistema.</p>

<pre><code class="language-C#">// BallView.cs

public class BallView : BounceElement
{
   void OnCollisionEnter() { app.Notify(BounceNotification.BallHitGround,this); }
}
</code></pre>

<hr />

<pre><code class="language-C#">// BounceController.cs

public class BounceController : BounceElement
{
   public void OnNotification(string p_event_path,Object p_target,params object[] p_data)
   {
      switch(p_event_path)
      {
         case BounceNotification.BallHitGround:
            app.model.bounces++;
            Debug.Log(“Bounce ”+app.model.bounce);
            if(app.model.bounces &gt;= app.model.winCondition)
            {
               app.view.ball.enabled = false;
               app.view.ball.GetComponent&lt;RigidBody&gt;().isKinematic=true;
               app.Notify(BounceNotification.GameComplete,this);            
            }
         break;
         
         case BounceNotification.GameComplete:
            Debug.Log(“Victoria!!”);
         break;
      } 
   }
}
</code></pre>

<p>Los <strong>proyectos más grandes tendrán muchas notificaciones</strong>. Por lo tanto, para evitar tener una gran estructura de switch-case, es aconsejable <strong>crear diferentes controladores</strong> y hacer que manejen diferentes ámbitos de notificación.</p>

<h2 id="reglas-de-oro">Reglas de oro</h2>

<p><strong>No hay ninguna &ldquo;Guía universal para la clasificación de MVC&rdquo;</strong> en ninguna parte. Pero hay algunas reglas simples que normalmente sigo para ayudarme a determinar si se debe definir algo como Modelo, Vista o Controlador, y también cuándo dividir una clase determinada en partes más pequeñas.</p>

<p>Por lo general, esto sucede de <strong>forma orgánica mientras pienso en la arquitectura del software</strong> o durante la creación de scripts.</p>

<p>y vuelvo a decir, es mi opinion, no algo universal.</p>

<h2 id="clasificación-de-clase">Clasificación de clase</h2>

<p><strong>Modelos</strong></p>

<ul>
<li>Mantenga los datos básicos y el estado de la aplicación, como jugador vida arma &hellip;</li>
<li>Serializar, deserializar y/o convertir entre tipos.</li>
<li>Cargar/guardar datos (localmente o en la web).</li>
<li>Notificar a los controladores el progreso de las operaciones.</li>
<li>Almacene el estado del juego para la máquina de estados finitos del juego.</li>
<li>Nunca acceda a Vistas.</li>
</ul>

<p><strong>Vista</strong></p>

<ul>
<li>Puede obtener datos de los Modelos para representar el estado del juego actualizado para el usuario. Por ejemplo, un método de Vista player.Run()puede usar internamente model.speed para manifestar las habilidades del jugador.</li>
<li>Nunca debería mutilar los modelos.</li>
<li>Implementa estrictamente las funcionalidades de su clase.</li>
</ul>

<p><strong>Controladores</strong></p>

<ul>
<li>No almacene datos básicos.</li>
<li>A veces puede filtrar las notificaciones de Vistas no deseadas.</li>
<li>Actualice y use los datos del Modelo.</li>
<li>Gestiona el flujo de trabajo de escena de Unity.</li>
</ul>

<h1 id="conclusión">Conclusión</h1>

<p>Hay toneladas de <strong>patrones de software</strong> por ahí. En este post intenté <strong>mostrar el que más me ayudó en proyectos</strong> anteriores. Los desarrolladores siempre deben absorber el conocimiento nuevo, pero siempre <strong>deberan cuestionarlo</strong> también. Espero que sirva como un trampolín a medida que desarrolles tu propio estilo.</p>

<p>Además, realmente te animo a <strong>buscar otros patrones</strong> y encontrar el que más te convenga. Un buen punto de partida es <a href="https://bit.ly/3oogQtW">este artículo de Wikipedia</a> , con su excelente lista de patrones y sus características.</p>

<hr />

<blockquote>
<p>Habilidad especial desbloqueada: juegos de Unity con el patrón MVC.</p>
</blockquote>

<hr />

<p><center><a href="https://bit.ly/3z1OdYu" class="button"><i class="fa fa-github-alt"></i> GitHub</a></center></p>

<p><center><img src="/img/ref.png" alt="001" /></center></p>


		
	</section>
    </div>

    <footer class="site-footer">
	<p class="text">&copy; 2022 - Moon Antonio</p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-89564434-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
