<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dev on Antonio Moon´s</title>
    <link>https://moonantonio.github.io/tags/dev/</link>
    <description>Recent content in Dev on Antonio Moon´s</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-es</language>
    <lastBuildDate>Sat, 27 Oct 2018 16:15:50 +0200</lastBuildDate>
    
	<atom:link href="https://moonantonio.github.io/tags/dev/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Ingeniería inversa :: ¿Qué sacar de esto?</title>
      <link>https://moonantonio.github.io/post/2018/dev/014/</link>
      <pubDate>Sat, 27 Oct 2018 16:15:50 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/014/</guid>
      <description>Llevo unos días profundizando sobre este tema, hasta ahora solo había realizado pequeñas investigaciones sobre esto, pero creo que es algo que puede ayudar mucho tanto para nuevos como para veteranos.
La ingeniería inversa (en inglés, reverse engineering) es el proceso de descubrir los principios tecnológicos de un objeto, herramienta, dispositivo o sistema, mediante el razonamiento abductivo (haciendo conjeturas) de su estructura, función y operación. Dicho de otra manera, se trata de tomar algo, por ejemplo un dispositivo mecánico o electrónico, para analizar su funcionamiento en detalle, con el objetivo de crear un dispositivo que haga la misma tarea o una similar sin copiar los detalles del original.</description>
    </item>
    
    <item>
      <title>Unity Shader de acumulación</title>
      <link>https://moonantonio.github.io/post/2018/dev/013/</link>
      <pubDate>Thu, 18 Oct 2018 03:42:27 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/013/</guid>
      <description>¿Te has preguntado cuánto tiempo se tarda en aplicar nieve a todas las texturas de tu juego? Probablemente muchas veces. Me gustaría mostrarle cómo crear un efecto de imagen (sombreado de espacio de pantalla) que cambiará inmediatamente la temporada de su escena en Unity.

¿Como funciona? En las imágenes de arriba puedes ver dos capturas de pantalla que presentan la misma escena. La única diferencia es que en el segundo habilité el efecto de nieve en la cámara.</description>
    </item>
    
    <item>
      <title>Localización usando .PO</title>
      <link>https://moonantonio.github.io/post/2018/dev/011/</link>
      <pubDate>Tue, 25 Sep 2018 19:26:11 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/011/</guid>
      <description>Traducir un juego a múltiples idiomas es una forma muy efectiva de exponerlo a nuevas audiencias. Sin embargo, puede convertirse en un verdadero dolor de cabeza si no lo hace de forma extensible y mantenible. Un sistema .po es una gran manera de administrar traducciones, y es un sistema útil para saber más que solo juegos. Analizaré formas en que puede ampliar el sistema para que sea más robusto, pero la mayoría de los detalles de estos dependen demasiado de su configuración para ser detallados por completo.</description>
    </item>
    
    <item>
      <title>¡Consejos esenciales de Gamedev &amp; Unity!</title>
      <link>https://moonantonio.github.io/post/2018/dev/010/</link>
      <pubDate>Mon, 10 Sep 2018 14:00:03 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/010/</guid>
      <description>¿Quieres saber cómo aprender rápidamente la programación de videojuegos?
Solo haz juegos.
 Aquí hay algunos consejos para ayudarlo en el camino:
1. No reinventar la rueda, use las herramientas incorporadas del motor Al trabajar en cualquier motor, como Unity o Unreal Engine, algunos desarrolladores, principalmente provenientes de un campo de ciencias de la computación, pueden tener tendencia a inclinarse y comenzar a trabajar en algoritmos o estructuras enormes sin saber si ya existen en el motor.</description>
    </item>
    
    <item>
      <title>Unity : Aseprite Workflow</title>
      <link>https://moonantonio.github.io/post/2018/dev/009/</link>
      <pubDate>Wed, 22 Aug 2018 21:00:28 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/009/</guid>
      <description>Administrar las hojas de sprites y las animaciones de pixel art dentro de Unity sin herramientas personalizadas es una pesadilla. Esto es lo que tiene que hacer solo para crear los assets para un solo personaje:
 Crea una textura (png) a través de un programa de pintura como Photoshop e importa un png en el proyecto de Unity. Establezca las configuraciones de importación deseadas para que la textura importada coincida con la misma configuración que ha utilizado para cada textura que haya importado.</description>
    </item>
    
    <item>
      <title>Estudio de UNET</title>
      <link>https://moonantonio.github.io/post/2018/dev/008/</link>
      <pubDate>Mon, 16 Jul 2018 17:18:59 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/008/</guid>
      <description>Esta entrada, es un recordatorio personal, después de hablar con amigos y de hablarme tan bien de UNET (Yo solo toque NET en Unity 3.5, :S), me entro el gusanico de ver esta nueva tecnología, por lo que decidí ponerme a investigar, pero descubrí que hay muy poca información sobre esto.
Detallo en más profundidad, hay información, pero del High API. Lo que yo quería ver es información sobre el Low API y de esto hay poco, asi que decidí crear esta entrada para guardar como recuerdo este estudio, por si próximamente tengo que volver a mirarlo (soy un neurótico del guardado de datos xD).</description>
    </item>
    
    <item>
      <title>Markdown - Lenguaje de marcado principal</title>
      <link>https://moonantonio.github.io/post/2018/dev/005/</link>
      <pubDate>Tue, 29 May 2018 00:10:41 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/005/</guid>
      <description>A continuación, veremos qué es Markdown exactamente, cómo funciona, qué es necesario para usarlo, en que entornos resulta práctico y, por supuesto, repasaremos brevemente algunas de las muchas herramientas que existen para poder utilizarlo, tanto en local como en la web.
Introducción Markdown es un lenguaje de marcado que facilita la aplicación de formato a un texto empleando una serie de caracteres de una forma especial. En principio, fue pensado para elaborar textos cuyo destino iba a ser la web con más rapidez y sencillez que si estuviésemos empleando directamente HTML.</description>
    </item>
    
    <item>
      <title>Tipos de lenguajes de programación {Bajo y Alto nivel}</title>
      <link>https://moonantonio.github.io/post/2018/dev/004/</link>
      <pubDate>Sat, 26 May 2018 02:38:41 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/004/</guid>
      <description>¿Que es un lenguaje de programación? Un lenguaje de programación, es un lenguaje que puede ser utilizado para controlar el comportamiento de una maquina. Consiste en un conjunto de reglas sintácticas y semánticas que definen su estructura y el significado de sus elementos, respectivamente.
El ordenador solo entiende un lenguaje conocido como código binario o código maquina, consistente en ceros y unos. Es decir, solo utiliza 0 y 1 para codificar cualquier acción.</description>
    </item>
    
    <item>
      <title>Unity3D Plugins ¿Que son?</title>
      <link>https://moonantonio.github.io/post/2018/dev/003/</link>
      <pubDate>Sat, 26 May 2018 00:57:20 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/003/</guid>
      <description>Hoy decidí compartir, algo que creo que no es un &amp;ldquo;conocimiento común&amp;rdquo; y no hay muchos recursos sobre ese tema en Internet, después de que varios colegas que están empezando en este mundo, me preguntasen como poder usar APIs en otros lenguajes en Unity3D, como por ejemplo el SKD de Steam que esta en C++ o las librerias .JAR de Android, decidí crear una entrada nueva. Mostrare como crear bibliotecas simples de C/C++ para Unity3D.</description>
    </item>
    
    <item>
      <title>ScriptableObjects</title>
      <link>https://moonantonio.github.io/post/2018/dev/002/</link>
      <pubDate>Tue, 17 Apr 2018 14:04:47 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/002/</guid>
      <description>Los Objetos Scriptables son un tipo especial de objeto de datos en Unity. Tienen varios beneficios importantes, pero es posible que no funcionen de manera ideal para cada situación.
Introducción a los Objetos Scriptables Puede pensar en un objeto programable como un objeto destinado solo a contener datos. Si ha estado utilizando clases o estructuras tradicionales de C# para objetos simples solo de datos, podría utilizarlas en su lugar. Por supuesto, usted se estará preguntando &amp;ldquo;por qué&amp;rdquo; le gustaría usar un Objeto Scriptable.</description>
    </item>
    
    <item>
      <title>MonoBehavior de Unity</title>
      <link>https://moonantonio.github.io/post/2018/dev/001/</link>
      <pubDate>Sat, 10 Mar 2018 20:34:29 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/001/</guid>
      <description>Unity puede estar desperdiciando mucho rendimiento de la CPU simplemente llamando a sus funciones MonoBehaviour. Realmente no importa lo que estén haciendo tus scripts. Si tiene cientos o miles de ellos, hay que tener en cuenta que hay un nuevo campo de optimización.
Métodos mágicos Las llamadas a funciones MonoBehaviour son lentas. Estoy hablando de funciones como Update() , LateUpdate(), OnRender(), etc. Son los llamados métodos mágicos, y si estas familiarizado con los lenguajes de programación orientados a objetos, este concepto parece llamar a un método usando mecanismo de reflexión (la reflexión habilita llamadas de métodos incluso si no conoce la interfaz).</description>
    </item>
    
    <item>
      <title>Clase Abstracta VS Interfaces</title>
      <link>https://moonantonio.github.io/post/2017/dev/025/</link>
      <pubDate>Fri, 16 Feb 2018 10:40:58 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/025/</guid>
      <description>El uso de clases abstractas y herencia para organizar la lógica de nuestras aplicaciones se puede sustituir o complementar con interfaces y métodos de extensión usando C#. En este artículo veremos un ejemplo de ambas aproximaciones así como sus ventajas e inconvenientes.
Clases Abstractas Las clases abstractas nos permiten tener una clase base con cierta funcionalidad común ya implementada, sobre la que podemos heredar y especificar algunos métodos. Para este ejemplo, la clase Transporte implementa el método Mover, y las clases Coche y Bicicleta especifican el número de ruedas.</description>
    </item>
    
    <item>
      <title>MVC simplificado</title>
      <link>https://moonantonio.github.io/post/2017/dev/014/</link>
      <pubDate>Tue, 07 Nov 2017 22:18:34 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/014/</guid>
      <description>Los programadores principiantes generalmente comienzan a aprender el oficio con el Hello World. A partir de ahí, sin un patrón de diseño, se suele aumentar sin ninguna metodología los proyectos y terminan siendo un caos. Cada nuevo desafío lleva a casa una lección importante:
Cuanto más grande es el proyecto, más grande es el espagueti.

Es fácil ver que en equipos grandes o pequeños, uno no puede hacer imprudentemente lo que le plazca.</description>
    </item>
    
    <item>
      <title>Sistema Gambits</title>
      <link>https://moonantonio.github.io/post/2017/dev/013/</link>
      <pubDate>Tue, 03 Oct 2017 21:24:19 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/013/</guid>
      <description>El sistema gambit, es un sistema que controla el comportamiento o acciones de un agente. Este agente tiene unas listas de prioridades en las que tiene comportamientos o acciones. El agente siempre accionara iteradamente su acción, siempre y cuando cumpla la condición, sino, pasara a la siguiente acción en la lista.
¿Dónde y por qué se necesitó crear el sistema gambit? En 1991, Square Soft, una desarrolladora de videojuegos famosa por sus sagas jrpg, necesitaba generar una serie de patrones para sus enemigos en su juego FF IV.</description>
    </item>
    
    <item>
      <title>Investigación Generación</title>
      <link>https://moonantonio.github.io/post/2017/dev/012/</link>
      <pubDate>Fri, 25 Aug 2017 22:40:40 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/012/</guid>
      <description>Generación de contenido procedural - Básico ¿Qué es el PCG? Aquí debo comenzar diciendo que en realidad una definición certera y aceptada por toda la academia no existe, es por eso que voy a mencionar diversas definiciones que obtuve de las referencias en las que me base:
 El PCG es la creación algorítmica de contenido de un juego, con entrada de información limitada o indirecta por parte del usuario.</description>
    </item>
    
    <item>
      <title>Comandos fundamentales de Windows</title>
      <link>https://moonantonio.github.io/post/2017/dev/011/</link>
      <pubDate>Thu, 27 Jul 2017 19:35:28 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/011/</guid>
      <description>Diferentes comandos útiles y básicos Cat Cat (de concatenar), es una maravillosa utilidad que nos permite visualizar el contenido de un archivo de texto sin la necesidad de un editor. Para utilizarlo solo debemos mencionarlo junto al archivo que deseamos visualizar:
$ cat prueba.txt  Ls Ls (de listar), permite listar el contenido de un directorio o fichero. La sintaxis es:
$ ls /home/directorio  El comando ls tiene varias opciones que permiten organizar la salida, lo que resulta particularmente útil cuando es muy grande.</description>
    </item>
    
    <item>
      <title>Investigación RPG-Táctico</title>
      <link>https://moonantonio.github.io/post/2017/dev/005/</link>
      <pubDate>Wed, 26 Apr 2017 20:39:00 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/005/</guid>
      <description>¿Qué se considera combate táctico? La definición de combate, es aquella situación en la que dos o más personajes interactúan entre sí con el objetivo de reducir al otro. En sí mismo un combate no tiene por qué ser necesariamente la representación directa de un enfrentamiento físico, también puede ser una batalla dialéctica.
El concepto de turno de combate se puede definir como “sucesión de momentos en los que los personajes actúan, que pueden ser calculado de antemano y no dependen de factores externos o aleatorios que no estén incluidos dentro del propio combate”.</description>
    </item>
    
    <item>
      <title>Algoritmos de búsqueda</title>
      <link>https://moonantonio.github.io/post/2017/dev/024/</link>
      <pubDate>Sun, 23 Apr 2017 17:17:22 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/024/</guid>
      <description>A* Los algoritmos de búsqueda nacen por la necesidad de crear un mecanismo de navegación autónoma, bien sea de robots, coches, o personajes en un videojuego. Algunos de los más conocidos son A, LPA, o D*.
El algoritmo de búsqueda A* (pronunciado &amp;ldquo;A asterisco&amp;rdquo; o &amp;ldquo;A start&amp;rdquo;) se clasifica dentro de los algoritmos de búsqueda. El algoritmo A* encuentra, siempre y cuando se cumplan unas determinadas condiciones, el camino de menor coste entre un nodo origen y uno objetivo.</description>
    </item>
    
    <item>
      <title>Unity &#43; GeForce Share (Shadow Play)</title>
      <link>https://moonantonio.github.io/post/2017/dev/004/</link>
      <pubDate>Fri, 31 Mar 2017 00:32:33 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/004/</guid>
      <description>De esta manera tus jugadores con tarjetas Nvidia podrán usar esta característica sin ningún problema.
GeForce Experience es una herramienta de las tarjetas Nvidia que permite gestionar tus juegos y optimizarlos, mantener los controladores actualizados y por supuesto la función “Share” que permite a los gamers compartir sus jugadas con los demás, esto es gracias a que la herramienta puede grabar nativamente una partida o bien una porción.
Quizás no lo hayas considerado pero esto es parte vital de la experiencia que tu juego debería brindarle a sus jugadores, y es posible que hayas compilado tu juego de manera que no sea compatible con esta característica, si no has configurado las siguientes opciones en Edit &amp;gt; Project Settings &amp;gt; Player.</description>
    </item>
    
    <item>
      <title>TextMesh Pro Unity3D</title>
      <link>https://moonantonio.github.io/post/2017/dev/023/</link>
      <pubDate>Mon, 20 Mar 2017 16:00:38 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/023/</guid>
      <description>TextMesh Pro se une a Unity.  Unity se complace en anunciar una nueva y poderosa adición a su suite de herramientas creativa: TextMesh Pro y su creador, Stephan Bouchard, se han unido a Unity!
 TextMesh Pro es un reemplazo de componentes de texto como texto de malla. TextMesh Pro utiliza SDF como su principal canal de renderizado de texto por lo que es posible representar el texto limpiamente en cualquier tamaño y resolución.</description>
    </item>
    
    <item>
      <title>Gestor de Escenas en Unity3D</title>
      <link>https://moonantonio.github.io/post/2017/dev/022/</link>
      <pubDate>Wed, 15 Mar 2017 13:02:10 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/022/</guid>
      <description>Evaluando lo necesario para el TFG, vi que requeríamos de un gestor de escenas, en la que se pudiera cambiar de escena, desde el editor y en runtime con variaciones.
 Editor -&amp;gt; cambiar generalmente de forma rápida y precisa.
Runtime -&amp;gt; cambiar entre cargar escena completa y cargar mediante Sync.
 Por ello propuse un Gestor de Escenas en la que uno mismo podría cambiar siempre de escena en cualquier lado.</description>
    </item>
    
    <item>
      <title>Consejos para organizar tus proyectos</title>
      <link>https://moonantonio.github.io/post/2017/dev/003/</link>
      <pubDate>Mon, 13 Mar 2017 19:36:17 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/003/</guid>
      <description>Vi a una persona en Quora, el otro día, preguntando cómo los programadores son capaces de escribir proyectos que constan de más de 10.000 líneas de código. Cuando el software se hace más grande, es más difícil de mantener y eso es un hecho. Así que aquí está la cosa - si usted no mantiene su proyecto organizado, vas a tener difícil mantener el ritmo. Más tarde, se encontrará perdiendo el tiempo con un proyecto desordenado en lugar de añadir nuevas características.</description>
    </item>
    
    <item>
      <title>Consejos para trabajar en equipo</title>
      <link>https://moonantonio.github.io/post/2017/dev/002/</link>
      <pubDate>Mon, 13 Mar 2017 19:10:22 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/002/</guid>
      <description>Ya sea que esté trabajando en un equipo o en solitario, usted debe saber cómo trabajar de manera eficiente en un proyecto con otras personas. No sólo va a hacer que el trabajo en un solo proyecto con alguien mucho sea más fácil, sino también mejorar su estilo de codificación y las habilidades de gestión de proyectos de manera significativa. No tiene que temer a nada, de verdad! Me gustaría explicar en unos pocos pasos cuáles son los aspectos más importantes del trabajo en equipo.</description>
    </item>
    
    <item>
      <title>Bakeo simple en Unity3D</title>
      <link>https://moonantonio.github.io/post/2017/dev/021/</link>
      <pubDate>Thu, 09 Mar 2017 22:24:10 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/021/</guid>
      <description>Primero preparamos la escena, con colores planos (simples) y algún objeto para representar en la escena, como una esfera.

Luego configuramos la iluminación para el quemado. Lo mas importante seria quitar el bakeo y seleccionar en tiempo real para preparar la escena entera.

Añadimos una pequeña animación para el movimiento de la luz direccional para ver en tiempo real el movimiento y si esta bien configurado.
public float v = 5; private void Update(){ this.</description>
    </item>
    
    <item>
      <title>MTodo Tool</title>
      <link>https://moonantonio.github.io/post/2017/dev/020/</link>
      <pubDate>Thu, 09 Mar 2017 21:54:00 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/020/</guid>
      <description>MTodo Tool es una herramienta sencilla para hacer un seguimiento del código en Unity3D
MTodo analiza la sintaxis de tu código con categorías / etiquetas. Por ejemplo, supongamos que tienes una categoría de BUG, en la linea de tu código donde se encuentra ese bug, pondría :
// &amp;lt; Categoria &amp;gt; &amp;lt; Mensaje &amp;gt; // BUG Aquí hay un bug.  MTodo analizara todas las lineas de tu solución y recopilara todas las etiquetas que tengan una concordancia con las categorías que se estipulen dentro de la herramienta, dando un sitio central donde se concentra toda la información encontrada.</description>
    </item>
    
    <item>
      <title>MDevScripts</title>
      <link>https://moonantonio.github.io/post/2017/dev/019/</link>
      <pubDate>Thu, 09 Mar 2017 21:50:01 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/019/</guid>
      <description>¿Por que publicar algo tan sencillo? Bueno, simplemente para poder hacer rápidamente funcionalidades sin tener que crear scripts nuevos y sin tener que arbitrar entre la solución mas optima, ya que en un prototipado lo que primero se hace es volver a crear los scripts básicos.
Por ello uso estos scripts, que hacen que por ejemplo el environment se cree rápidamente y asi concentrarme en la mecánica que en si es la que mas trabajo lleva de un prototipo.</description>
    </item>
    
    <item>
      <title>Unity3D Carga de nivel [Logo]</title>
      <link>https://moonantonio.github.io/post/2017/dev/018/</link>
      <pubDate>Sat, 04 Mar 2017 23:23:58 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/018/</guid>
      <description>Escena de carga en Unity3D con varios ejemplos. Se puede usar plugins como NGUI o si lo prefieres el mismo UGUI incorporado en Unity 5+. Esta version esta probada para Unity3D 5.5.1p4.
El planteamiento es que el logo siguiente, hiciera un fade-in y un fade-out en un tiempo. Es decir una transición hacia dentro y otra hacia afuera como se ve en el siguiente ejemplo. El repositorio de ejemplo lo tenéis al final de la entrada.</description>
    </item>
    
    <item>
      <title>MEGA API CLIENT [C#]</title>
      <link>https://moonantonio.github.io/post/2017/dev/017/</link>
      <pubDate>Wed, 01 Mar 2017 23:32:52 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/017/</guid>
      <description>(ACTUALIZADO A 21/07/2022)
Mega es el sucesor del servicio de archivos en la nube Megaupload, para aquellos a los que no les suena ninguno de los dos es como un dropbox, un servicio gratuito o de pago dependiendo del espacio que utilizamos para poder subir nuestros archivos. En mi opinión es un servicio increíble que nos permite almacenar copias de seguridad de archivos en la nube y/o compartirlos.
En esta entrada mostraré como desde un proyecto en .</description>
    </item>
    
    <item>
      <title>Explicación IA básica</title>
      <link>https://moonantonio.github.io/post/2017/dev/015/</link>
      <pubDate>Wed, 01 Mar 2017 23:25:12 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/015/</guid>
      <description>IA en Videojuegos Hay diferentes tipos de IA clasificados por el tipo de uso de su algoritmo.
Los mas comunes en videojuegos son:
 Juegos de suma cero: Minimax Búsqueda de caminos: A* Agentes inteligentes Maquina de estados finitos Redes neuronales Algoritmos genéticos Redes evolutivas: rtNeat  Juegos de suma cero son juegos en los que solo tienen 2 resultados, o 3. Como por ejemplo el ajedrez, Minimax es un algoritmo para realizar la elección de la mejor acción para ganar.</description>
    </item>
    
    <item>
      <title>Comandos fundamentales de GIT</title>
      <link>https://moonantonio.github.io/post/2017/dev/016/</link>
      <pubDate>Wed, 01 Mar 2017 23:20:28 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/016/</guid>
      <description>Los comandos fundamentales que se usan en git. Los comandos fundamentales que se usan en git son muchos, pero dependiendo del tipo de control de versiones que uno esta realizando en ese momento.
Por ejemplo si estas haciendo un control de versiones de un proyecto en el que solo participas tu, usaras los indispensables ya que con dejar el proyecto abierto para que otros puedas entrar sin problemas de cambiar la config sobra.</description>
    </item>
    
  </channel>
</rss>