<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dev on Antonio Moon´s</title>
    <link>https://moonantonio.github.io/categories/dev/</link>
    <description>Recent content in Dev on Antonio Moon´s</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-es</language>
    <lastBuildDate>Wed, 07 Nov 2018 16:51:53 +0100</lastBuildDate>
    
	<atom:link href="https://moonantonio.github.io/categories/dev/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Pechos en videojuegos - Fisicas</title>
      <link>https://moonantonio.github.io/post/2018/comun/021/</link>
      <pubDate>Wed, 07 Nov 2018 16:51:53 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/comun/021/</guid>
      <description>Los pechos oscilan. Ellos caen y se pueden mover. A lo largo de los años, muchos juegos han intentado emular el comportamiento de los pechos. Incluso hay un término para ello: &amp;ldquo;Breast physics&amp;rdquo;.
Si has jugado a juegos que tienen física en los pechos, probablemente hayas visto lo poco común que son los juegos que muestran los pechos como realmente se mueven: bolsas de grasa afectadas por la gravedad. En cambio, es más probable que un juego represente los pechos como globos de helio que tienen sus propias mentes y fuerzas gravitatorias.</description>
    </item>
    
    <item>
      <title>Ingeniería inversa :: ¿Qué sacar de esto?</title>
      <link>https://moonantonio.github.io/post/2018/dev/014/</link>
      <pubDate>Sat, 27 Oct 2018 16:15:50 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/014/</guid>
      <description>Llevo unos dias profundizando sobre este tema, hasta ahora solo habia realizado pequeñas investigaciones sobre esto, pero creo que es algo que puede ayudar mucho tanto para nuevos como para veteranos.
La ingeniería inversa (en inglés, reverse engineering) es el proceso de descubrir los principios tecnológicos de un objeto, herramienta, dispositivo o sistema, mediante el razonamiento abductivo (haciendo conjeturas) de su estructura, función y operación. Dicho de otra manera, se trata de tomar algo, por ejemplo un dispositivo mecánico o electrónico, para analizar su funcionamiento en detalle, con el objetivo de crear un dispositivo que haga la misma tarea o una similar sin copiar los detalles del original.</description>
    </item>
    
    <item>
      <title>¡Consejos esenciales de Gamedev &amp; Unity!</title>
      <link>https://moonantonio.github.io/post/2018/dev/010/</link>
      <pubDate>Mon, 10 Sep 2018 14:00:03 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/010/</guid>
      <description>¿Quieres saber cómo aprender rápidamente la programación de videojuegos?
Solo haz juegos.
 Aquí hay algunos consejos para ayudarlo en el camino:
1. No reinventar la rueda, use las herramientas incorporadas del motor Al trabajar en cualquier motor, como Unity o Unreal Engine, algunos desarrolladores, principalmente provenientes de un campo de ciencias de la computación, pueden tener tendencia a inclinarse y comenzar a trabajar en algoritmos o estructuras enormes sin saber si ya existen en el motor.</description>
    </item>
    
    <item>
      <title>Estudio de UNET</title>
      <link>https://moonantonio.github.io/post/2018/dev/008/</link>
      <pubDate>Mon, 16 Jul 2018 17:18:59 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/008/</guid>
      <description>Esta entrada, es un recordatorio personal, despues de hablar con amigos y de hablarme tan bien de UNET (Yo solo toque NET en Unity 3.5, :S), me entro el gusanico de ver esta nueva tecnologia, por lo que decidi ponerme a investigar, pero descubri que hay muy poca información sobre esto.
Detallo en más profundidad, hay información, pero del High API. Lo que yo queria ver es información sobre el Low API y de esto hay poco, asi que decidi crear esta entrada para guardar como recuerdo este estudio, por si proximamente tengo que volver a mirarlo (soy un neurotico del guardado de datos xD).</description>
    </item>
    
    <item>
      <title>WebClient gestor de conexiones Unity3D</title>
      <link>https://moonantonio.github.io/post/2018/dev/007/</link>
      <pubDate>Fri, 06 Jul 2018 23:46:32 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/007/</guid>
      <description>WebClient es un componente del lado del cliente, un modelo distribuido de aplicaciones de niveles múltiples utilizado para crear y desarrollar aplicaciones empresariales. Los componentes del lado del cliente son típicamente aplicaciones de computadora que se ejecutan en la computadora de un usuario y se conectan a un servidor. Estos componentes realizan operaciones en el lado del cliente, ya que pueden necesitar acceso a la información disponible solo en el lado del cliente, como la entrada del usuario, o porque el servidor carece de la potencia de procesamiento necesaria en tales operaciones.</description>
    </item>
    
    <item>
      <title>¿Qué pruebas debemos hacerle a nuestro videojuego?</title>
      <link>https://moonantonio.github.io/post/2018/comun/004/</link>
      <pubDate>Tue, 05 Jun 2018 17:17:37 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/comun/004/</guid>
      <description>“Los test no son opcionales”. Esto que parece a muchos una verdad, sigue siendo uno de los temas pendientes en el mundo del desarrollo de aplicaciones de software actual.
Sí, increíblemente aún hay muchos compañeros “del metal” que no son conscientes que programar sin pruebas no solo es como hacer acrobacias en el trapecio sin red de seguridad, sino además una fuente de errores, malas prácticas y ansiedad.
Y por ello quiero repasar los fundamentos básicos de las pruebas que debiéramos aplicar, cada uno en su necesidad, a nuestros desarrollos.</description>
    </item>
    
    <item>
      <title>ScriptableObjects</title>
      <link>https://moonantonio.github.io/post/2018/dev/002/</link>
      <pubDate>Tue, 17 Apr 2018 14:04:47 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/002/</guid>
      <description>Los Objetos Scriptables son un tipo especial de objeto de datos en Unity. Tienen varios beneficios importantes, pero es posible que no funcionen de manera ideal para cada situación.
Introducción a los Objetos Scriptables Puede pensar en un objeto programable como un objeto destinado solo a contener datos. Si ha estado utilizando clases o estructuras tradicionales de C# para objetos simples solo de datos, podría utilizarlas en su lugar. Por supuesto, usted se estará preguntando &amp;ldquo;por qué&amp;rdquo; le gustaría usar un Objeto Scriptable.</description>
    </item>
    
    <item>
      <title>MonoBehavior en Unity</title>
      <link>https://moonantonio.github.io/post/2018/dev/001/</link>
      <pubDate>Sat, 10 Mar 2018 20:34:29 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2018/dev/001/</guid>
      <description>Unity puede estar desperdiciando mucho rendimiento de la CPU simplemente llamando a sus funciones MonoBehaviour. Realmente no importa lo que estén haciendo tus scripts. Si tiene cientos o miles de ellos, hay que tener en cuenta que hay un nuevo campo de optimización.
Métodos mágicos Las llamadas a funciones MonoBehaviour son lentas. Estoy hablando de funciones como Update() , LateUpdate(), OnRender(), etc. Son los llamados métodos mágicos, y si estas familiarizado con los lenguajes de programación orientados a objetos, este concepto parece llamar a un método usando mecanismo de reflexión (la reflexión habilita llamadas de métodos incluso si no conoce la interfaz).</description>
    </item>
    
    <item>
      <title>MVC simplificado.</title>
      <link>https://moonantonio.github.io/post/2017/dev/014/</link>
      <pubDate>Tue, 07 Nov 2017 22:18:34 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/014/</guid>
      <description>Introduccion Los programadores principiantes generalmente comienzan a aprender el oficio con el Hello World. A partir de ahí, sin un patron de diseño, se suele aumentar sin ninguna metodologia los proyectos y terminan siendo un caos. Cada nuevo desafío lleva a casa una lección importante:
Cuanto más grande es el proyecto, más grande es el espagueti.

Es fácil ver que en equipos grandes o pequeños, uno no puede hacer imprudentemente lo que le plazca.</description>
    </item>
    
    <item>
      <title>Maquina de estados Finitos</title>
      <link>https://moonantonio.github.io/post/2017/dev/010/</link>
      <pubDate>Wed, 05 Jul 2017 18:59:56 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/010/</guid>
      <description>Las aplicaciones del sistema FSM en general y en videojuegos Se denomina máquina de estados a un modelo de comportamiento de un sistema con entradas y salidas, en donde las salidas dependen no sólo de las señales de entradas actuales sino también de las anteriores.
Finito, si el conjunto de estados de la máquina es finito, este es el único tipo de máquinas de estados que podemos modelar en un computador en la actualidad; debido a esto se suelen utilizar los términos máquina de estados y máquina de estados finitos de forma intercambiable.</description>
    </item>
    
    <item>
      <title>Pequeño proyecto manager escenas en memoria</title>
      <link>https://moonantonio.github.io/post/2017/dev/009/</link>
      <pubDate>Tue, 27 Jun 2017 13:55:04 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/009/</guid>
      <description>Carga y descarga en memoria de escenas Despues de ver varios ejemplos de escenas, y ver la API de Unity3D para la carga y descarga de escenas en Unity3D, he desarrollado un pequeño ejemplo en modo de practica para poder experimentar la carga y descarga de niveles en escena.
El proyecto esta alojado en Github, y es open source, tiene las diferentes funciones -&amp;gt;
Carga y descarga de escenas Control de escenas vecinas Tiempo maximo de carga Posibilidad de agregar eventos en diferentes estados(Cargando, cargado)  Y algunas funcionalidades mas, junto con una muestra de ejemplo.</description>
    </item>
    
    <item>
      <title>Actualizacion GAIA</title>
      <link>https://moonantonio.github.io/post/2017/dev/008/</link>
      <pubDate>Sat, 10 Jun 2017 22:27:45 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/008/</guid>
      <description>Actualizado nuevos modelos de Gaia He agregado nuevos modelos de mecanicas al repositorio de Gaia.
Blend Color 2048 
ShooterISO 
Cut 
Saltos 
.\Moon</description>
    </item>
    
    <item>
      <title>Effectos necesarios para el TFG</title>
      <link>https://moonantonio.github.io/post/2017/dev/007/</link>
      <pubDate>Tue, 06 Jun 2017 18:47:18 +0200</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/dev/007/</guid>
      <description>Investigacion de BaseMesh Unity3d El otro dia intentando crear efectos en la nueva GUI de Unity3D, vi que se puede modificar una malla de la uGUI, cogiendo sus vertices y añadiendolos a una lista, modificar los vertices de la lista a gusto.
Por aqui empece a desarrollar unos efectos que necesitaba para mi proyecto de TFG.
 El repositorio lo dejo en GitHub para que cualquiera que quiera usarlos o seguir desarrollando nuevos efectos, tenga acceso a ellos.</description>
    </item>
    
  </channel>
</rss>